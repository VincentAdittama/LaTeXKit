#!/usr/bin/env bash
# LaTeXKit CLI - Component-based LaTeX template manager
# Inspired by shadcn/ui
#
# MAIN-ONLY WORKFLOW:
# This CLI supports trunk-based development (all work on main branch).
# Projects are managed via `documents/` folder and `.active_project` file.

set -e

VERSION="1.1.0"
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# DETEKSI MODE OPERASI (The Smart Logic)
# -----------------------------------------------------------

# Cek 1: Apakah ada Environment Variable dari Wrapper? (Explicit override)
if [[ -n "${LATEXKIT_SUPER_REPO_ROOT:-}" ]]; then
    PROJECT_ROOT="$LATEXKIT_SUPER_REPO_ROOT"
    MODE="Submodule (Wrapper)"

# Cek 2: Apakah saya berada di dalam Git Superproject? (Native Git check)
# Perintah ini akan return path ke Repo B jika script ini ada di dalam submodule
elif SUPER_ROOT=$(git rev-parse --show-superproject-working-tree 2>/dev/null) && [[ -n "$SUPER_ROOT" ]]; then
    PROJECT_ROOT="$SUPER_ROOT"
    MODE="Submodule (Native)"

# Cek 3: Fallback ke Standalone (Repo A di-clone langsung)
else
    # Gunakan root dari git repo ini sendiri
    PROJECT_ROOT="$(git -C "$SCRIPT_DIR" rev-parse --show-toplevel 2>/dev/null || echo "$SCRIPT_DIR")"
    MODE="Standalone"
fi

# Export agar bisa dibaca oleh child scripts (common.sh dll)
export LATEXKIT_PROJECT_ROOT="$PROJECT_ROOT"
REGISTRY_DIR="$SCRIPT_DIR/.latexkit/registry"
CONFIG_FILE="latexkit.config.json"



# Source common utilities
source "$SCRIPT_DIR/.latexkit/scripts/bash/common.sh" 2>/dev/null || true

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
MAGENTA='\033[0;35m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# Helper functions
print_header() {
    local title="LaTeXKit v${VERSION}"
    local subtitle="Component-based LaTeX Templates"
    
    # Calculate the width needed (use the longer line)
    local title_len=${#title}
    local subtitle_len=${#subtitle}
    local content_width=$((title_len > subtitle_len ? title_len : subtitle_len))
    
    # Add padding (4 spaces on each side)
    local total_width=$((content_width + 8))
    
    # Generate horizontal borders dynamically
    local horizontal_border=$(printf '‚ïê%.0s' $(seq 1 $total_width))
    
    # Calculate padding for centering
    local title_padding=$(( (total_width - title_len) / 2 ))
    local subtitle_padding=$(( (total_width - subtitle_len) / 2 ))
    
    echo -e "${MAGENTA}"
    echo "‚ïî${horizontal_border}‚ïó"
    printf "‚ïë%*s%s%*s‚ïë\n" $title_padding "" "$title" $((total_width - title_len - title_padding)) ""
    printf "‚ïë%*s%s%*s‚ïë\n" $subtitle_padding "" "$subtitle" $((total_width - subtitle_len - subtitle_padding)) ""
    echo "‚ïö${horizontal_border}‚ïù"
    echo -e "${NC}"
}

print_success() {
    echo -e "${GREEN}‚úì${NC} $1"
}

print_error() {
    echo -e "${RED}‚úó${NC} $1"
}

print_info() {
    echo -e "${BLUE}‚Ñπ${NC} $1"
}

print_warning() {
    echo -e "${YELLOW}‚ö†${NC} $1"
}

# Command: start (formerly init)
cmd_start() {
    print_header
    
    local layout="academic-assignment"
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            --layout)
                layout="$2"
                shift 2
                ;;
            *)
                shift
                ;;
        esac
    done
    
    # Check if layout exists
    if [[ ! -d "$REGISTRY_DIR/layouts/$layout" ]]; then
        print_error "Layout '$layout' not found!"
        echo ""
        echo "Available layouts:"
        ls -1 "$REGISTRY_DIR/layouts/" | sed 's/^/  - /'
        exit 1
    fi
    
    # Check if already started
    if [[ -d "latex_source" ]]; then
        print_warning "Project already started!"
        read -p "Do you want to restart? (y/N): " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            exit 0
        fi
        rm -rf latex_source
    fi
    
    echo -e "${CYAN}Starting LaTeXKit project with layout: ${layout}${NC}"
    echo ""
    
    # Create project structure
    mkdir -p latex_source/{sections,images}
    
    # 1. Copy ONLY the content structure (sections), NOT the core template files
    print_info "Setting up project structure..."
    cp -r "$REGISTRY_DIR/layouts/$layout/sections" latex_source/
    
    # 2. Create a special main.tex that references the registry
    # We calculate the relative path from latex_source/ to the registry
    # Assuming standard structure: <repo>/documents/<branch>/latex_source
    # And registry is at: <repo>/registry
    # So we need to go up: ../../../registry
    
    # However, for the "Private Wrapper" strategy, the path might be different.
    # We will use a placeholder that defaults to the local registry for now,
    # but can be easily changed or symlinked.
    
    print_info "Creating main.tex with template references..."
    
    # Read the original main.tex
    local original_main="$REGISTRY_DIR/layouts/$layout/main.tex"
    
    # Create the new main.tex
    # We inject the \newcommand{\latexKitPath} at the top
    echo "%!TeX root = main.tex" > latex_source/main.tex
    echo "%% LATEXKIT CONFIGURATION" >> latex_source/main.tex
    echo "%% This path points to the shared template registry." >> latex_source/main.tex
    echo "%% In a Private Wrapper setup, this should point to your submodule." >> latex_source/main.tex
    
    # Default path: assumes we are in the same repo (monorepo style for now)
    # ../../../registry -> from latex_source -> document_dir -> documents -> root -> registry
    # Wait, the user is currently in the root of the template repo.
    # If they run ./latexkit start, they are at root.
    # latex_source is created at root/latex_source.
    # So path to registry is ../registry
    
    echo "\newcommand{\latexKitPath}{../.latexkit/registry/layouts/$layout}" >> latex_source/main.tex
    echo "" >> latex_source/main.tex
    
    # Append the rest of the original main.tex, but replace \input{preamble.tex} with \input{\latexKitPath/preamble.tex}
    # and remove the \documentclass line if we want to prepend it? No, keep it standard.
    
    # Actually, let's just copy the file and use sed to patch it.
    cat "$original_main" >> latex_source/main.tex
    
    # Patch the inputs to use \latexKitPath
    # We need to be careful not to break local inputs like sections/
    
    # 1. Fix preamble input
    sed -i '' 's|\\input{preamble.tex}|\\input{\\latexKitPath/preamble.tex}|g' latex_source/main.tex
    
    # 2. Fix component inputs if any are pre-included (usually not in main.tex but good to be safe)
    # sed -i '' 's|\\input{components/|\\input{\\latexKitPath/../../components/|g' latex_source/main.tex
    
    # Create config file
    print_info "Creating configuration file..."
    cat > "$CONFIG_FILE" <<EOF
{
  "project": {
    "name": "My LaTeX Project",
    "layout": "$layout",
    "language": "indonesian"
  },
  "components": [],
  "style": {
    "font": "Times New Roman",
    "fontSize": "12pt",
    "lineSpacing": 1.5,
    "margin": "1in"
  },
    "paths": {
        "source": "latex_source",
        "output": "build",
        "bibliography": "zotero_export/<your-export>.bib"
    }
}
EOF
    
    print_success "Project started successfully (Reference Mode)!"
    echo ""
    echo "Next steps:"
    echo "  1. Edit latex_source/sections/*.tex with your content"
    echo "  2. Add components: ./latexkit add <component>"
    echo "  3. Build your document: ./latexkit build"
}

# Command: add
cmd_add() {
    local component="$1"
    
    if [[ -z "$component" ]]; then
        print_error "Please specify a component to add"
        echo "Usage: ./latexkit add <component>"
        echo ""
        echo "Available components:"
        ls -1 "$REGISTRY_DIR/components/" | sed 's/\.tex$//' | sed 's/^/  - /'
        exit 1
    fi
    
    # Check if project is started
    if [[ ! -d "latex_source" ]]; then
        print_error "Project not started! Run './latexkit start' first"
        exit 1
    fi
    
    # Check if component exists
    if [[ ! -f "$REGISTRY_DIR/components/${component}.tex" ]]; then
        print_error "Component '$component' not found!"
        echo ""
        echo "Available components:"
        ls -1 "$REGISTRY_DIR/components/" | sed 's/\.tex$//' | sed 's/^/  - /'
        exit 1
    fi
    
    # Update config
    if command -v jq &> /dev/null; then
        local temp_config=$(mktemp)
        jq ".components += [\"$component\"] | .components |= unique" "$CONFIG_FILE" > "$temp_config"
        mv "$temp_config" "$CONFIG_FILE"
    fi
    
    print_success "Component '$component' registered!"
    echo ""
    print_info "To use this component, add this line to your preamble (or main.tex):"
    echo ""
    echo "  \\input{\\latexKitPath/../../components/${component}.tex}"
    echo ""
    print_info "Note: We reference the shared component directly so updates apply automatically."
}

# Command: list
cmd_list() {
    print_header
    
    echo -e "${CYAN}üì¶ Available Layouts:${NC}"
    ls -1 "$REGISTRY_DIR/layouts/" | sed 's/^/  - /'
    echo ""
    
    echo -e "${CYAN}üß© Available Components:${NC}"
    ls -1 "$REGISTRY_DIR/components/" | sed 's/\.tex$//' | sed 's/^/  - /'
    echo ""
    
    if [[ -f "$CONFIG_FILE" ]]; then
        echo -e "${CYAN}‚úì Installed Components:${NC}"
        if command -v jq &> /dev/null; then
            jq -r '.components[]' "$CONFIG_FILE" | sed 's/^/  - /'
        else
            echo "  (Install jq to see installed components)"
        fi
    fi
}

# Command: build
cmd_build() {
    if [[ ! -d "latex_source" ]]; then
        # Try to find active project
        local active=$(cat "$PROJECT_ROOT/.latexkit/.active_project" 2>/dev/null || echo "")
        if [[ -n "$active" ]]; then
            local project_dir="$PROJECT_ROOT/documents/$active"
            if [[ -d "$project_dir/latex_source" ]]; then
                print_info "Building active project: $active"
                (cd "$project_dir" && cmd_build)
                return $?
            fi
        fi

        print_error "Project not started! Run './latexkit start' first"
        exit 1
    fi
    
    print_info "Building LaTeX document..."
    
    mkdir -p build
    cd latex_source
    
    # Compile with lualatex (for fontspec support) using explicit output directory
    print_info "Pass 1: Initial compilation..."
    lualatex -output-directory=../build main.tex || {
        print_error "LaTeX compilation failed! Check ../build/main.log for details"
        cd ..
        exit 1
    }
    
    # Run biber for bibliography if any .bib file exists under zotero_export
    local bibfile
    bibfile=$(find ../zotero_export -type f -name '*.bib' 2>/dev/null | head -n 1 || true)
    if [[ -n "$bibfile" ]]; then
        print_info "Pass 2: Processing bibliography..."
        cd ../build
        biber main || print_warning "Biber encountered issues (check main.blg)"
        cd ../latex_source
        
        print_info "Pass 3: Resolving citations..."
        lualatex -output-directory=../build main.tex || {
            print_error "LaTeX compilation failed on pass 3!"
            cd ..
            exit 1
        }
        
        print_info "Pass 4: Final compilation..."
        lualatex -output-directory=../build main.tex || {
            print_error "LaTeX compilation failed on pass 4!"
            cd ..
            exit 1
        }
    fi
    
    cd ..
    
    # Verify PDF is in correct location
    if [[ -f "build/main.pdf" ]]; then
        print_success "Document compiled successfully!"
        echo ""
        print_info "Output: build/main.pdf"
        
        # Warn if PDF exists in wrong location
        if [[ -f "latex_source/main.pdf" ]]; then
            print_warning "PDF also found in latex_source/ (wrong location)"
            print_info "This should not happen with correct compilation"
        fi
    else
        print_error "PDF was not generated!"
        if [[ -f "latex_source/main.pdf" ]]; then
            print_error "PDF found in latex_source/ instead of build/"
            print_error "This indicates a compilation issue"
        fi
        print_info "Check build/main.log for details"
        exit 1
    fi
}

# Command: clean
cmd_clean() {
    if [[ ! -d "build" ]] && [[ ! -d "latex_source" ]]; then
        # Try to find active project
        local active=$(cat "$PROJECT_ROOT/.latexkit/.active_project" 2>/dev/null || echo "")
        if [[ -n "$active" ]]; then
            local project_dir="$PROJECT_ROOT/documents/$active"
            if [[ -d "$project_dir" ]]; then
                print_info "Cleaning active project: $active"
                (cd "$project_dir" && cmd_clean)
                return $?
            fi
        fi
    fi

    print_info "Cleaning build artifacts..."
    rm -rf build/
    print_success "Build directory cleaned"
}

# Command: commit (smart git commit with workflow labels)
cmd_commit() {
    local commit_script="$SCRIPT_DIR/.latexkit/scripts/bash/smart-commit.sh"
    
    if [[ ! -x "$commit_script" ]]; then
        print_error "Smart commit script not found or not executable!"
        print_info "Expected: $commit_script"
        exit 1
    fi
    
    # Pass all arguments to the smart-commit script
    "$commit_script" "$@"
}

# =================================================================
# MAIN-ONLY WORKFLOW COMMANDS
# =================================================================

# Command: new (create a new project in documents/)
# Usage: ./latexkit new "Project Description" [--layout academic-assignment] [--semester <name>]
cmd_new() {
    print_header
    
    local description=""
    local layout="academic-assignment"
    local short_name=""
    local semester=""
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            --layout)
                layout="$2"
                shift 2
                ;;
            --short-name)
                short_name="$2"
                shift 2
                ;;
            --semester)
                semester="$2"
                shift 2
                ;;
            *)
                if [[ -z "$description" ]]; then
                    description="$1"
                fi
                shift
                ;;
        esac
    done
    
    if [[ -z "$description" ]]; then
        print_error "Please provide a project description"
        echo "Usage: ./latexkit new \"Your Project Description\" [--layout academic-assignment] [--semester <name>]"
        exit 1
    fi
    
    # Check if layout exists
    if [[ ! -d "$REGISTRY_DIR/layouts/$layout" ]]; then
        print_error "Layout '$layout' not found!"
        echo ""
        echo "Available layouts:"
        ls -1 "$REGISTRY_DIR/layouts/" | sed 's/^/  - /'
        exit 1
    fi
    
    # Semester Logic
    local last_semester_file="$PROJECT_ROOT/.latexkit/.last_semester"
    mkdir -p "$(dirname "$last_semester_file")"
    
    if [[ -z "$semester" ]]; then
        # Try to read last semester
        if [[ -f "$last_semester_file" ]]; then
            semester=$(cat "$last_semester_file")
            print_info "Using last semester: $semester (use --semester to override)"
        fi
    else
        # Save new semester
        echo "$semester" > "$last_semester_file"
    fi
    
    echo -e "${CYAN}Creating new project: ${description}${NC}"
    if [[ -n "$semester" ]]; then
        echo -e "${BLUE}Semester: ${semester}${NC}"
    fi
    echo ""
    
    # Determine documents root for this project
    local docs_root="$PROJECT_ROOT/documents"
    if [[ -n "$semester" ]]; then
        docs_root="$PROJECT_ROOT/documents/$semester"
    fi
    
    # Ensure documents directory exists
    mkdir -p "$docs_root"
    
    # Find next project number (globally unique or per-semester? User said "sort of that thing", usually unique ID is better for finding)
    # But if we nest, we might want unique IDs across the whole repo to avoid confusion.
    # Let's scan ALL documents/ recursively to find the highest number to ensure global uniqueness.
    
    local highest=0
    # Use find to list all directories in documents/ (max depth 2) matching NNN-*
    while IFS= read -r dir; do
        local dirname=$(basename "$dir")
        if [[ "$dirname" =~ ^([0-9]{3})- ]]; then
            local number=$((10#${BASH_REMATCH[1]}))
            if [[ "$number" -gt "$highest" ]]; then
                highest=$number
            fi
        fi
    done < <(find "$PROJECT_ROOT/documents" -maxdepth 2 -type d -name "[0-9][0-9][0-9]-*")
    
    local next=$((highest + 1))
    local project_num=$(printf "%03d" "$next")
    
    # Generate project slug
    local slug=""
    if [[ -n "$short_name" ]]; then
        slug=$(echo "$short_name" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9]/-/g' | sed 's/-\+/-/g; s/^-//; s/-$//')
    else
        # Use generate_concise_slug if available
        if command -v generate_concise_slug &>/dev/null || declare -f generate_concise_slug &>/dev/null; then
            slug=$(generate_concise_slug "$description")
        else
            # Fallback: simple slug generation
            slug=$(echo "$description" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9]/-/g' | sed 's/-\+/-/g; s/^-//; s/-$//' | cut -c1-48)
        fi
    fi
    
    local project_id="${project_num}-${slug}"
    local project_dir="$docs_root/$project_id"
    
    print_info "Project ID: $project_id"
    
    # Create project directory structure
    mkdir -p "$project_dir"/{checklists,latex_source/{sections,images},build,assignment_info,zotero_export}
    mkdir -p "$project_dir"/generated_work/{research,outlines,drafts,conversion,compilation,reviews}
    
    # Add .gitkeep files to preserve empty directories
    for dir in "$project_dir"/build "$project_dir"/assignment_info "$project_dir"/zotero_export \
               "$project_dir"/generated_work/{research,outlines,drafts,conversion,compilation,reviews}; do
        touch "$dir/.gitkeep"
    done
    
    # Copy layout template files
    print_info "Copying layout template: $layout"
    cp -r "$REGISTRY_DIR/layouts/$layout/sections"/* "$project_dir/latex_source/sections/" 2>/dev/null || true
    
    # Calculate relative path to registry
    # Depth: documents/<semester>/<project>/latex_source -> 4 levels up
    # Depth: documents/<project>/latex_source -> 3 levels up
    local registry_rel_path="../../../.latexkit/registry/layouts/$layout"
    if [[ -n "$semester" ]]; then
        registry_rel_path="../../../../.latexkit/registry/layouts/$layout"
    fi
    
    # Create main.tex with template reference
    cat > "$project_dir/latex_source/main.tex" <<EOF
%!TeX root = main.tex
%% LATEXKIT CONFIGURATION
%% This path points to the shared template registry.
\\newcommand{\\latexKitPath}{$registry_rel_path}

$(cat "$REGISTRY_DIR/layouts/$layout/main.tex")
EOF
    
    # Patch preamble input to use latexKitPath
    sed -i '' 's|\\input{preamble.tex}|\\input{\\latexKitPath/preamble.tex}|g' "$project_dir/latex_source/main.tex"
    
    # Create basic start.md
    local today=$(date +%Y-%m-%d)
    cat > "$project_dir/start.md" <<EOF
# Project Start File: $description

**Document ID**: \`$project_id\`  
**Created**: \`$today\`  
**Status**: \`Draft\`
EOF
    if [[ -n "$semester" ]]; then
        echo "**Semester**: \`$semester\`" >> "$project_dir/start.md"
    fi
    cat >> "$project_dir/start.md" <<EOF

---

## Executive Summary

### Purpose
$description

### Type
**Document Type**: \`Assignment\`

### Document Output Language
**Final Document Language**: \`Indonesian\`

### Key Requirements
1. [Requirement 1]
2. [Requirement 2]
3. [Requirement 3]

---

## Notes

<!-- Add project notes here -->
EOF

    # Create project-level config file
    cat > "$project_dir/latexkit.config.json" <<EOF
{
  "project": {
    "name": "$description",
    "layout": "$layout",
    "language": "indonesian",
    "semester": "$semester"
  },
  "components": [],
  "style": {
    "font": "Times New Roman",
    "fontSize": "12pt",
    "lineSpacing": 1.5,
    "margin": "1in"
  },
  "paths": {
    "source": "latex_source",
    "output": "build",
    "bibliography": "zotero_export"
  }
}
EOF
    
    # Set as active project
    echo "$project_id" > "$PROJECT_ROOT/.latexkit/.active_project"
    
    print_success "Project created: $project_dir"
    echo ""
    echo -e "${GREEN}Project '$project_id' is now active!${NC}"
    echo ""
    echo "Next steps:"
    echo "  1. Edit $project_dir/start.md with project details"
    echo "  2. Run /latexkit.start in Copilot Chat to complete setup"
    echo "  3. Or use ./latexkit build to compile"
    echo ""
    echo "Switch projects anytime with: ./latexkit switch $project_num"
}

# Command: switch (change active project)
# Usage: ./latexkit switch <project_id|project_num>
cmd_switch() {
    local project_id="$1"
    
    if [[ -z "$project_id" ]]; then
        # Show project list and prompt
        echo -e "${CYAN}Available projects:${NC}"
        echo ""
        
        if declare -f list_projects >/dev/null; then
            list_projects
        else
            # Fallback listing
            local active=$(cat "$PROJECT_ROOT/.latexkit/.active_project" 2>/dev/null || echo "")
            for dir in "$PROJECT_ROOT/documents"/*; do
                if [[ -d "$dir" ]]; then
                    local dirname=$(basename "$dir")
                    if [[ "$dirname" =~ ^[0-9]{3}- ]]; then
                        if [[ "$dirname" == "$active" ]]; then
                            echo -e "  ${GREEN}*${NC} $dirname ${GREEN}(active)${NC}"
                        else
                            echo "    $dirname"
                        fi
                    fi
                fi
            done
        fi
        
        echo ""
        read -p "Enter project number or ID to switch to: " -r project_id
        echo ""
        
        if [[ -z "$project_id" ]]; then
            print_info "Switch cancelled"
            exit 0
        fi
    fi
    
    # Use shared logic to find project directory
    local project_dir=""
    if declare -f find_document_dir_by_id >/dev/null; then
        project_dir=$(find_document_dir_by_id "$PROJECT_ROOT" "$project_id")
    else
        # Fallback logic (non-recursive)
        if [[ "$project_id" =~ ^[0-9]+$ ]]; then
            local padded=$(printf "%03d" "$((10#$project_id))")
            for dir in "$PROJECT_ROOT/documents"/"$padded"-*; do
                if [[ -d "$dir" ]]; then
                    project_dir="$dir"
                    break
                fi
            done
        else
            if [[ -d "$PROJECT_ROOT/documents/$project_id" ]]; then
                project_dir="$PROJECT_ROOT/documents/$project_id"
            fi
        fi
    fi
    
    # Validate project exists
    if [[ -z "$project_dir" || ! -d "$project_dir" ]]; then
        print_error "Project not found: $project_id"
        exit 1
    fi
    
    # Get actual project ID from directory name
    local real_project_id=$(basename "$project_dir")
    
    # Set active project
    echo "$real_project_id" > "$PROJECT_ROOT/.latexkit/.active_project"
    print_success "Switched to project: $real_project_id"
    
    # Show project info
    local start_file="$project_dir/start.md"
    if [[ -f "$start_file" ]]; then
        local title=$(head -5 "$start_file" | grep "^# " | head -1 | sed 's/^# //')
        if [[ -n "$title" ]]; then
            echo ""
            print_info "Project: $title"
        fi
        
        # Show semester if available
        local semester=$(grep "^\*\*Semester\*\*:" "$start_file" | cut -d'`' -f2)
        if [[ -n "$semester" ]]; then
            print_info "Semester: $semester"
        fi
    fi
}

# Command: projects (list all projects)
cmd_projects() {
    print_header
    
    echo -e "${CYAN}üìÅ Projects in documents/:${NC}"
    echo ""
    
    # Use shared listing logic from common.sh
    if declare -f list_projects >/dev/null; then
        list_projects
    else
        # Fallback if common.sh not sourced or function missing
        local active=$(cat "$PROJECT_ROOT/.latexkit/.active_project" 2>/dev/null || echo "")
        for dir in "$PROJECT_ROOT/documents"/*; do
            if [[ -d "$dir" ]]; then
                local dirname=$(basename "$dir")
                if [[ "$dirname" =~ ^[0-9]{3}- ]]; then
                    if [[ "$dirname" == "$active" ]]; then
                        echo -e "  ${GREEN}*${NC} $dirname ${GREEN}(active)${NC}"
                    else
                        echo "    $dirname"
                    fi
                fi
            fi
        done
    fi
    
    echo ""
    echo "Commands:"
    echo "  ./latexkit switch <num>  Switch to a project (e.g., ./latexkit switch 1)"
    echo "  ./latexkit new \"desc\"    Create a new project"
}

# Command: current (show current active project)
cmd_current() {
    local active=$(cat "$PROJECT_ROOT/.latexkit/.active_project" 2>/dev/null || echo "")
    
    if [[ -z "$active" ]]; then
        print_warning "No active project"
        echo ""
        echo "Set an active project:"
        echo "  ./latexkit switch <project_id>"
        echo "  ./latexkit new \"Project Description\""
        exit 0
    fi
    
    echo -e "${CYAN}Active project:${NC} $active"
    
    local project_dir="$PROJECT_ROOT/documents/$active"
    local start_file="$project_dir/start.md"
    
    if [[ -f "$start_file" ]]; then
        local title=$(head -5 "$start_file" | grep "^# " | head -1 | sed 's/^# Project Start File: //')
        if [[ -n "$title" ]]; then
            echo "Title: $title"
        fi
    fi
    
    echo ""
    echo "Project path: $project_dir"
}

# Command: reset (destructive clean - strips to template)
cmd_reset() {
    print_header
    
    # Detect workflow type
    local is_copilot_workflow=false
    if [[ -d "documents" ]]; then
        is_copilot_workflow=true
    fi
    
    echo -e "${RED}‚ö†Ô∏è  WARNING: DESTRUCTIVE OPERATION ‚ö†Ô∏è${NC}"
    echo ""
    
    if [[ "$is_copilot_workflow" == true ]]; then
        # Copilot workflow - interactive reset
        echo -e "${CYAN}What would you like to reset?${NC}"
        echo "  [1] This project only"
        echo "  [2] All projects"
        echo "  [3] Cancel"
        echo ""
        read -p "Select option [1-3]: " -r scope_choice
        echo ""
        
        if [[ "$scope_choice" == "3" ]]; then
            print_info "Reset cancelled"
            exit 0
        fi
        
        if [[ "$scope_choice" == "1" ]]; then
            # Reset current project only
            
            # Get current branch and project
            if ! command -v git &> /dev/null || [[ ! -d ".git" ]]; then
                print_error "Git not available or not in a git repository"
                exit 1
            fi
            
            local current_branch=$(git branch --show-current 2>/dev/null)
            if [[ -z "$current_branch" ]] || [[ "$current_branch" == "main" ]] || [[ "$current_branch" == "master" ]]; then
                print_error "Not on a project branch. Please switch to a project branch first."
                exit 1
            fi
            
            # Extract project number from branch (e.g., "001-project-name" -> "001")
            local project_num=$(echo "$current_branch" | grep -o '^[0-9]\{3\}')
            if [[ -z "$project_num" ]]; then
                print_error "Current branch does not follow naming convention (NNN-project-name)"
                exit 1
            fi
            
            # Find project directory
            local project_dir=$(find documents -maxdepth 1 -type d -name "${project_num}-*" 2>/dev/null | head -n 1)
            if [[ -z "$project_dir" ]]; then
                print_error "Project directory not found: documents/${project_num}-*"
                exit 1
            fi
            
            echo -e "${YELLOW}This will:${NC}"
            echo "  ‚Ä¢ Delete project folder: $project_dir"
            echo "  ‚Ä¢ Create RESET commit on current branch"
            echo "  ‚Ä¢ Ask about merging to main"
            echo ""
            echo -e "${RED}This action CANNOT be undone!${NC}"
            echo ""
            read -p "Type 'RESET' to confirm: " -r
            echo
            
            if [[ "$REPLY" != "RESET" ]]; then
                print_info "Reset cancelled"
                exit 0
            fi
            
            # Execute reset
            if [[ -f "$project_dir/start.md" ]]; then
                print_info "Resetting project..."
                
                # Backup start.md and config
                cp "$project_dir/start.md" "$project_dir/start.md.bak"
                cp "$project_dir/latexkit.config.json" "$project_dir/latexkit.config.json.bak"
                
                # Nuke
                rm -rf "$project_dir"/*
                
                # Restore
                mv "$project_dir/start.md.bak" "$project_dir/start.md"
                mv "$project_dir/latexkit.config.json.bak" "$project_dir/latexkit.config.json"
                
                # Re-create structure
                mkdir -p "$project_dir"/{checklists,latex_source/{sections,images},build,assignment_info,zotero_export}
                mkdir -p "$project_dir"/generated_work/{research,outlines,drafts,conversion,compilation,reviews}
                
                # Add .gitkeep
                for dir in "$project_dir"/build "$project_dir"/assignment_info "$project_dir"/zotero_export \
                           "$project_dir"/generated_work/{research,outlines,drafts,conversion,compilation,reviews}; do
                    touch "$dir/.gitkeep"
                done
                
                # Get layout from config
                local layout=$(grep -o '"layout": "[^"]*"' "$project_dir/latexkit.config.json" | cut -d'"' -f4)
                if [[ -z "$layout" ]]; then layout="academic-assignment"; fi
                
                # Copy layout
                print_info "Restoring layout: $layout"
                cp -r "$REGISTRY_DIR/layouts/$layout/sections"/* "$project_dir/latex_source/sections/" 2>/dev/null || true
                
                # Restore main.tex
                cat > "$project_dir/latex_source/main.tex" <<EOF
%!TeX root = main.tex
%% LATEXKIT CONFIGURATION
%% This path points to the shared template registry.
\newcommand{\latexKitPath}{../../../.latexkit/registry/layouts/$layout}

$(cat "$REGISTRY_DIR/layouts/$layout/main.tex")
EOF
                sed -i '' 's|\input{preamble.tex}|\input{\latexKitPath/preamble.tex}|g' "$project_dir/latex_source/main.tex"
                
                print_success "Project reset successfully!"
            else
                print_error "start.md not found, cannot safely reset."
            fi
            
            # Commit the reset
            print_info "Creating RESET commit..."
            git add -A
            git commit -m "RESET: Remove project ${project_num}" -m "Deleted project folder and all contents" 2>/dev/null || print_warning "Nothing to commit or commit failed"
            
            # Ask about merging to main
            echo ""
            echo -e "${CYAN}Would you like to merge this branch to main?${NC}"
            read -p "Merge to main? [y/N]: " -r merge_choice
            echo ""
            
            if [[ "$merge_choice" =~ ^[Yy]$ ]]; then
                print_info "Switching to main branch..."
                local main_branch="main"
                git checkout main 2>/dev/null || {
                    git checkout master 2>/dev/null && main_branch="master"
                }
                
                if [[ $? -eq 0 ]]; then
                    print_info "Merging branch '$current_branch' into $main_branch..."
                    if git merge --no-ff "$current_branch" --no-edit 2>&1 | tee /tmp/latexkit_merge_output.txt; then
                        print_success "Successfully merged '$current_branch' into $main_branch"
                        print_info "Branch '$current_branch' kept for reference"
                        print_info "Now on branch: $main_branch"
                    else
                        print_error "Merge failed!"
                        cat /tmp/latexkit_merge_output.txt
                        print_warning "Staying on branch: $main_branch"
                        print_info "You may need to resolve conflicts manually"
                    fi
                    rm -f /tmp/latexkit_merge_output.txt
                else
                    print_error "Could not switch to main/master branch"
                    print_info "Staying on branch: $current_branch"
                fi
            else
                print_info "Staying on branch: $current_branch"
            fi
            
            echo ""
            print_success "Reset complete!"
            
        elif [[ "$scope_choice" == "2" ]]; then
            # Reset all projects
            
            echo -e "${YELLOW}This will:${NC}"
            echo "  ‚Ä¢ Delete entire documents/ directory"
            echo "  ‚Ä¢ Create RESET commit"
            echo "  ‚Ä¢ Merge to main branch"
            echo ""
            echo -e "${RED}This action CANNOT be undone!${NC}"
            echo ""
            read -p "Type 'RESET' to confirm: " -r
            echo
            
            if [[ "$REPLY" != "RESET" ]]; then
                print_info "Reset cancelled"
                exit 0
            fi
            
            # Delete all projects
            print_info "Deleting all projects..."
            rm -rf documents/
            print_success "All projects deleted"
            
            # Commit the reset
            print_info "Creating RESET commit..."
            if command -v git &> /dev/null && [[ -d ".git" ]]; then
                local current_branch=$(git branch --show-current 2>/dev/null)
                git add -A
                git commit -m "RESET: Remove all projects" -m "Deleted entire documents directory" 2>/dev/null || print_warning "Nothing to commit or commit failed"
                
                # Merge to main
                print_info "Switching to main branch..."
                local main_branch="main"
                git checkout main 2>/dev/null || {
                    git checkout master 2>/dev/null && main_branch="master"
                }
                
                if [[ $? -eq 0 ]]; then
                    if [[ -n "$current_branch" ]] && [[ "$current_branch" != "main" ]] && [[ "$current_branch" != "master" ]]; then
                        print_info "Merging branch '$current_branch' into $main_branch..."
                        if git merge --no-ff "$current_branch" --no-edit 2>&1; then
                            print_success "Successfully merged '$current_branch' into $main_branch"
                        else
                            print_warning "Merge encountered issues"
                        fi
                    else
                        print_info "Already on $main_branch, no merge needed"
                    fi
                else
                    print_warning "Could not switch to main/master branch"
                fi
            fi
            
            echo ""
            print_success "Reset complete!"
            
        else
            print_error "Invalid option selected"
            exit 1
        fi
        
    else
        # Traditional CLI workflow reset
        if [[ ! -f "$CONFIG_FILE" ]]; then
            print_error "No LaTeXKit project found in current directory!"
            exit 1
        fi
        
        echo "This will:"
        echo "  ‚Ä¢ Delete all content in latex_source/"
        echo "  ‚Ä¢ Remove all build artifacts"
        echo "  ‚Ä¢ Reset to a clean template state (Reference Mode)"
        echo ""
        echo -e "${YELLOW}This action CANNOT be undone!${NC}"
        echo ""
        read -p "Type 'RESET' to confirm: " -r
        echo
        
        if [[ "$REPLY" != "RESET" ]]; then
            print_info "Reset cancelled"
            exit 0
        fi
        
        # Get current layout from config
        local layout="academic-assignment"
        if command -v jq &> /dev/null; then
            layout=$(jq -r '.project.layout' "$CONFIG_FILE")
        fi
        
        # Check if layout exists
        if [[ ! -d "$REGISTRY_DIR/layouts/$layout" ]]; then
            print_error "Layout '$layout' not found in registry!"
            print_info "Defaulting to 'academic-assignment' layout"
            layout="academic-assignment"
        fi
        
        print_info "Resetting project to template state..."
        
        # Remove existing directories
        rm -rf latex_source/
        rm -rf build/
        
        # Recreate structure
        mkdir -p latex_source/{sections,images}
        
        # Copy fresh layout files (Sections only)
        print_info "Restoring layout structure: $layout"
        cp -r "$REGISTRY_DIR/layouts/$layout/sections" latex_source/
        
        # Recreate main.tex with references
        print_info "Restoring main.tex with template references..."
        local original_main="$REGISTRY_DIR/layouts/$layout/main.tex"
        
        echo "%!TeX root = main.tex" > latex_source/main.tex
        echo "%% LATEXKIT CONFIGURATION" >> latex_source/main.tex
        echo "%% This path points to the shared template registry." >> latex_source/main.tex
        echo "\newcommand{\latexKitPath}{../registry/layouts/$layout}" >> latex_source/main.tex
        echo "" >> latex_source/main.tex
        
        cat "$original_main" >> latex_source/main.tex
        sed -i '' 's|\\input{preamble.tex}|\\input{\\latexKitPath/preamble.tex}|g' latex_source/main.tex
        
        # Reset config file
        print_info "Resetting configuration..."
        cat > "$CONFIG_FILE" <<EOF
{
  "project": {
    "name": "My LaTeX Project",
    "layout": "$layout",
    "language": "indonesian"
  },
  "components": [],
  "style": {
    "font": "Times New Roman",
    "fontSize": "12pt",
    "lineSpacing": 1.5,
    "margin": "1in"
  },
  "paths": {
    "source": "latex_source",
    "output": "build",
    "bibliography": "zotero_export/<your-export>.bib"
  }
}
EOF
        
        echo ""
        print_success "Project reset to clean template state (Reference Mode)!"
        print_info "Layout: $layout"
    fi
}

# Command: help
# Command: prompt (generate context prompt)
cmd_prompt() {
    local script="$SCRIPT_DIR/.latexkit/scripts/bash/gen-prompt.sh"
    if [[ ! -x "$script" ]]; then
        print_error "Prompt generator script not found or not executable!"
        print_info "Expected: $script"
        exit 1
    fi
    "$script" "$@"
}

cmd_help() {
    print_header
    echo "Usage: ./latexkit <command> [options]"
    echo ""
    echo -e "${CYAN}Project Management (Main-Only Workflow):${NC}"
    echo "  new \"description\"       Create a new project in documents/"
    echo "  switch <id|num>         Switch active project (e.g., switch 1 or switch 001-my-project)"
    echo "  projects                List all projects"
    echo "  current                 Show current active project"
    echo ""
    echo -e "${CYAN}LaTeX Template Commands:${NC}"
    echo "  start [--layout <name>] Initialize LaTeX template in current directory"
    echo "  add <component>         Add a component to your project"
    echo "  list                    List available layouts and components"
    echo "  build                   Compile the LaTeX document"
    echo "  clean                   Remove build artifacts"
    echo ""
    echo -e "${CYAN}Git Integration:${NC}"
    echo "  commit [stage] [opts]   Smart git commit with workflow labels"
    echo "  reset                   üî• Reset projects (DESTRUCTIVE)"
    echo ""
    echo "  help                    Show this help message"
    echo ""
    echo -e "${CYAN}Examples:${NC}"
    echo "  ./latexkit new \"Essay Sejarah Indonesia\"   # Create new project"
    echo "  ./latexkit switch 1                         # Switch to project 001"
    echo "  ./latexkit projects                         # List all projects"
    echo "  ./latexkit build                            # Compile current project"
    echo "  ./latexkit commit research                  # Commit with RESEARCH label"
}

# Main command router
main() {
    if [[ $# -eq 0 ]]; then
        cmd_help
        exit 0
    fi
    
    case "$1" in
        # Main-Only Workflow Commands
        new)
            shift
            cmd_new "$@"
            ;;
        switch)
            shift
            cmd_switch "$@"
            ;;
        projects|proj|ls)
            cmd_projects
            ;;
        current|status)
            cmd_current
            ;;
        # Legacy/Template Commands
        start)
            shift
            cmd_start "$@"
            ;;
        init)
            # Keep init as alias for backwards compatibility
            print_warning "Command 'init' is deprecated. Use 'start' instead."
            shift
            cmd_start "$@"
            ;;
        add)
            shift
            cmd_add "$@"
            ;;
        list)
            cmd_list
            ;;
        build)
            cmd_build
            ;;
        clean)
            cmd_clean
            ;;
        commit)
            shift
            cmd_commit "$@"
            ;;
        prompt|gen)
            shift
            cmd_prompt "$@"
            ;;
        reset)
            cmd_reset
            ;;
        help|--help|-h)
            cmd_help
            ;;
        *)
            print_error "Unknown command: $1"
            echo ""
            cmd_help
            exit 1
            ;;
    esac
}

main "$@"
