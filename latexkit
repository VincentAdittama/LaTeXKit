#!/usr/bin/env bash
# LaTeXKit CLI - Component-based LaTeX template manager
# Inspired by shadcn/ui
#
# MAIN-ONLY WORKFLOW:
# This CLI supports trunk-based development (all work on main branch).
# Projects are managed via `documents/` folder and `.latexkit-workspace` state file.

set -e

# =================================================================
# ARCHITECTURE OVERVIEW: SUPER REPO VS STANDALONE
# =================================================================
# This script is designed to work in two distinct architectural contexts:
#
# 1. STANDALONE MODE (Repo A)
#    - The standard usage where you clone this repo and use it directly.
#    - The "Project Root" is simply the root of this git repository.
#    - Documents live in `documents/` relative to this script.
#
# 2. SUBMODULE MODE (Repo B / Super Repo)
#    - The advanced usage where this repo is a submodule inside a larger "Super Repo".
#    - The "Project Root" is the root of the Super Repo (Repo B), NOT this submodule.
#    - This allows you to have a private "Work Repo" that pulls in this public "Template Repo".
#    - We detect this mode automatically via git or explicit environment variables.
#
# Why this matters:
# - All git operations (commits, diffs) must run from the Project Root.
# - Path resolution for `documents/` must be relative to the Project Root.
# =================================================================

VERSION="1.1.0"
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# OPERATION MODE DETECTION (The Smart Logic)
# -----------------------------------------------------------
# This section determines how the script is being run and sets the project root accordingly.
# It's crucial for supporting both standalone usage and submodule integration.

# Check 1: Is there an Environment Variable from a Wrapper? (Explicit override)
# If a parent script (like a wrapper in a Super Repo) sets this, we trust it blindly.
if [[ -n "${LATEXKIT_SUPER_REPO_ROOT:-}" ]]; then
    PROJECT_ROOT="$LATEXKIT_SUPER_REPO_ROOT"
    MODE="Submodule (Wrapper)"

# Check 2: Am I inside a Git Superproject? (Native Git check)
# This command returns the path to the Super Repo (Repo B) if this script is running inside a submodule.
# It's a robust way to detect if we are just a component in a larger system.
elif SUPER_ROOT=$(git -C "$SCRIPT_DIR" rev-parse --show-superproject-working-tree 2>/dev/null) && [[ -n "$SUPER_ROOT" ]]; then
    PROJECT_ROOT="$SUPER_ROOT"
    MODE="Submodule (Native)"

# Check 3: Fallback to Standalone (Direct Clone)
# If neither of the above, we assume we are running as a standalone repository (Repo A).
# We use the git root of this script's location.
else
    # Use the root of this git repo itself
    PROJECT_ROOT="$(git -C "$SCRIPT_DIR" rev-parse --show-toplevel 2>/dev/null || echo "$SCRIPT_DIR")"
    MODE="Standalone"
fi

# Export agar bisa dibaca oleh child scripts (common.sh dll)
export LATEXKIT_PROJECT_ROOT="$PROJECT_ROOT"
REGISTRY_DIR="$SCRIPT_DIR/registry"
CONFIG_FILE="latexkit.config.json"



# Source common utilities
source "$SCRIPT_DIR/scripts/bash/common.sh" 2>/dev/null || true

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
MAGENTA='\033[0;35m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# Helper functions
print_header() {
    local title="LaTeXKit v${VERSION}"
    local subtitle="Component-based LaTeX Templates"
    
    # Calculate the width needed (use the longer line)
    local title_len=${#title}
    local subtitle_len=${#subtitle}
    local content_width=$((title_len > subtitle_len ? title_len : subtitle_len))
    
    # Add padding (4 spaces on each side)
    local total_width=$((content_width + 8))
    
    # Generate horizontal borders dynamically
    local horizontal_border=$(printf 'â•%.0s' $(seq 1 $total_width))
    
    # Calculate padding for centering
    local title_padding=$(( (total_width - title_len) / 2 ))
    local subtitle_padding=$(( (total_width - subtitle_len) / 2 ))
    
    echo -e "${MAGENTA}"
    echo "â•”${horizontal_border}â•—"
    printf "â•‘%*s%s%*sâ•‘\n" $title_padding "" "$title" $((total_width - title_len - title_padding)) ""
    printf "â•‘%*s%s%*sâ•‘\n" $subtitle_padding "" "$subtitle" $((total_width - subtitle_len - subtitle_padding)) ""
    echo "â•š${horizontal_border}â•"
    echo -e "${NC}"
}

print_success() {
    echo -e "${GREEN}âœ“${NC} $1"
}

print_error() {
    echo -e "${RED}âœ—${NC} $1"
}

print_info() {
    echo -e "${BLUE}â„¹${NC} $1"
}

print_warning() {
    echo -e "${YELLOW}âš ${NC} $1"
}

# Command: init (formerly start)
cmd_init() {
    print_header
    
    # Safety Check: Prevent running in Super Repo Root
    if [[ -f "latexkit" ]] && [[ -d ".latexkit" ]] && [[ -d "documents" ]]; then
        print_error "You are in the Super Repo Root!"
        print_info "You should not initialize a project here."
        print_info "Navigate to a project folder or create a new one with './latexkit new'"
        exit 1
    fi

    local layout="academic-assignment"
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            --layout)
                layout="$2"
                shift 2
                ;;
            *)
                shift
                ;;
        esac
    done
    
    # Check if layout exists
    if [[ ! -d "$REGISTRY_DIR/layouts/$layout" ]]; then
        print_error "Layout '$layout' not found!"
        echo ""
        echo "Available layouts:"
        ls -1 "$REGISTRY_DIR/layouts/" | sed 's/^/  - /'
        exit 1
    fi
    
    # Check if already started
    if [[ -d "latex_source" ]]; then
        print_warning "Project already initialized!"
        read -p "Do you want to re-initialize? (y/N): " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            exit 0
        fi
        rm -rf latex_source
    fi
    
    echo -e "${CYAN}Initializing LaTeXKit project with layout: ${layout}${NC}"
    echo ""
    
    # Create project structure
    mkdir -p latex_source/{sections,images}
    
    # 1. Copy ONLY the content structure (sections), NOT the core template files
    print_info "Setting up project structure..."
    cp -r "$REGISTRY_DIR/layouts/$layout/sections" latex_source/
    
    # 2. Create a special main.tex that references the registry
    print_info "Creating main.tex with template references..."
    
    # Read the original main.tex from the registry
    local original_main="$REGISTRY_DIR/layouts/$layout/main.tex"
    
    # Create the new main.tex
    echo "%!TeX root = main.tex" > latex_source/main.tex
    echo "%% LATEXKIT CONFIGURATION" >> latex_source/main.tex
    echo "%% This path points to the shared template registry." >> latex_source/main.tex
    
    # Default path logic: assumes we are in the same repo (monorepo style for now)
    # We need to calculate relative path from here to registry
    # This is tricky because we don't know depth.
    # For now, we assume standard depth or rely on user to fix if custom.
    # Actually, let's try to be smart.
    local rel_path=""
    if command -v python3 &>/dev/null; then
        rel_path=$(python3 -c "import os.path; print(os.path.relpath('$REGISTRY_DIR/layouts/$layout', '$(pwd)/latex_source'))")
    else
        # Fallback if python is not available (unlikely on macOS)
        # We just assume a standard depth of 3 levels up if we can't calculate it
        rel_path="../../../.latexkit/registry/layouts/$layout"
    fi
    
    echo "\newcommand{\latexKitPath}{$rel_path}" >> latex_source/main.tex
    echo "" >> latex_source/main.tex
    
    cat "$original_main" >> latex_source/main.tex
    
    # Patch the inputs to use \latexKitPath
    sed -i '' 's|\\input{preamble.tex}|\\input{\\latexKitPath/preamble.tex}|g' latex_source/main.tex
    
    # Create config file
    print_info "Creating configuration file..."
    cat > "$CONFIG_FILE" <<EOF
{
  "project": {
    "name": "My LaTeX Project",
    "layout": "$layout",
    "language": "indonesian"
  },
  "components": [],
  "style": {
    "font": "Times New Roman",
    "fontSize": "12pt",
    "lineSpacing": 1.5,
    "margin": "1in"
  },
    "paths": {
        "source": "latex_source",
        "output": "build",
        "bibliography": "zotero_export/<your-export>.bib"
    }
}
EOF
    
    print_success "Project initialized successfully!"
    echo ""
    echo "Next steps:"
    echo "  1. Edit latex_source/sections/*.tex with your content"
    echo "  2. Generate an AI Prompt to start working: ./latexkit start"
}

# Command: start (Generate AI Prompt)
cmd_start() {
    print_header
    
    # Check if we are in a project
    if [[ ! -f "latexkit.config.json" ]]; then
        # Try to find active project
        local active=$(get_active_project)
        
        # If no active project, ask user to select one
        if [[ -z "$active" ]]; then
            print_warning "No active project found."
            echo "Please select a project to start:"
            echo ""
            
            # List projects and capture selection
            # We'll use a simple indexed list
            local projects=()
            local i=1
            
            # Find all projects
            while IFS= read -r dir; do
                if [[ -d "$dir" && ( -f "$dir/start.md" || -f "$dir/latexkit.config.json" ) ]]; then
                    projects+=("$dir")
                    local dirname=$(basename "$dir")
                    echo "  [$i] $dirname"
                    ((i++))
                fi
            done < <(find "$PROJECT_ROOT/documents" -maxdepth 2 -type d -not -path '*/.*')
            
            if [[ ${#projects[@]} -eq 0 ]]; then
                print_error "No projects found in documents/!"
                exit 1
            fi
            
            echo ""
            read -p "Enter number (1-$((i-1))): " -r selection
            
            if [[ "$selection" =~ ^[0-9]+$ ]] && (( selection >= 1 && selection < i )); then
                local selected_dir="${projects[$((selection-1))]}"
                local selected_id=$(basename "$selected_dir")
                
                # Set as active
                set_workspace_state "ACTIVE_PROJECT" "$selected_id"
                active="$selected_id"
                print_success "Selected project: $active"
                echo ""
            else
                print_error "Invalid selection."
                exit 1
            fi
        fi

        if [[ -n "$active" ]]; then
             local project_dir=""
            if declare -f find_document_dir_by_id >/dev/null; then
                project_dir=$(find_document_dir_by_id "$PROJECT_ROOT" "$active")
            else
                project_dir="$PROJECT_ROOT/documents/$active"
            fi
            
            if [[ -n "$project_dir" && -d "$project_dir" ]]; then
                print_info "Switching context to active project: $active"
                (cd "$project_dir" && cmd_start)
                return $?
            fi
        fi
        
        print_error "Could not locate project directory for: $active"
        exit 1
    fi
    
    echo -e "${CYAN}Generating AI Agent Prompt...${NC}"
    echo ""
    
    local project_name="Untitled Project"
    if command -v jq &> /dev/null; then
        project_name=$(jq -r '.project.name // "Untitled Project"' latexkit.config.json)
    fi
    
    local start_content=""
    if [[ -f "start.md" ]]; then
        start_content=$(cat "start.md")
    else
        start_content="(No start.md found)"
    fi
    
    local config_content=$(cat latexkit.config.json)
    
    # Scan assignment_info for context files
    local context_files_list=""
    if [[ -d "assignment_info" ]]; then
        context_files_list=$(find assignment_info -type f -not -name '.gitkeep' | sed 's/^/   - /')
    fi
    if [[ -z "$context_files_list" ]]; then
        context_files_list="   (No context files found in assignment_info)"
    fi

    # Construct the prompt
    local prompt_file=$(mktemp)
    
    cat > "$prompt_file" <<EOF
You are an AI assistant helping with a LaTeX project.

# Project Context
**Project Name**: $project_name
**Path**: $(pwd)

## Configuration (latexkit.config.json)
\`\`\`json
$config_content
\`\`\`

## Project Brief (start.md)
\`\`\`markdown
$start_content
\`\`\`

## Assignment Context (assignment_info)
The following files contain the assignment details, rubrics, and reference materials. 
**CRITICAL**: You must read these files to understand the requirements.
$context_files_list

## Directory Structure
\`\`\`
$(ls -R | grep ":$" | head -n 20 | sed 's/:$//' | sed 's/[^-][^\/]*\//--/g' | sed 's/^/   /' | sed 's/-/|/')
(truncated)
\`\`\`

# Task
I am ready to start working on this assignment. 
Please review the 'Project Brief', 'Configuration', and the files listed in 'Assignment Context'.

**Your Goal**: Help me execute this assignment accurately and efficiently.

**Step 1: Analysis & Clarification**
1.  **Read Context**: Analyze the files in \`assignment_info\` to understand the exact requirements and grading criteria.
2.  **Cross-Check**: Compare the requirements against the current project state.
3.  **Clarify**: If any information is missing, ambiguous, or if you need specific instructions (e.g., "What is the deadline?", "What is the target length?"), ASK ME NOW. Do not make assumptions.

**Step 2: Execution Plan**
Once we are aligned, propose a logical next step (e.g., creating an outline, drafting a specific section, or setting up the bibliography).

If you need to run commands, use the \`./latexkit\` CLI.
EOF

    # Output to user
    echo -e "${YELLOW}--- COPY THE PROMPT BELOW ---${NC}"
    cat "$prompt_file"
    echo -e "${YELLOW}-----------------------------${NC}"
    
    # Optional: Copy to clipboard (macOS only)
    if command -v pbcopy &> /dev/null; then
        cat "$prompt_file" | pbcopy
        echo ""
        print_success "Prompt copied to clipboard!"
    fi
    
    rm "$prompt_file"
}

# Command: add
cmd_add() {
    local component="$1"
    
    if [[ -z "$component" ]]; then
        print_error "Please specify a component to add"
        echo "Usage: ./latexkit add <component>"
        echo ""
        echo "Available components:"
        ls -1 "$REGISTRY_DIR/components/" | sed 's/\.tex$//' | sed 's/^/  - /'
        exit 1
    fi
    
    # Check if project is started
    if [[ ! -d "latex_source" ]]; then
        print_error "Project not started! Run './latexkit start' first"
        exit 1
    fi
    
    # Check if component exists
    if [[ ! -f "$REGISTRY_DIR/components/${component}.tex" ]]; then
        print_error "Component '$component' not found!"
        echo ""
        echo "Available components:"
        ls -1 "$REGISTRY_DIR/components/" | sed 's/\.tex$//' | sed 's/^/  - /'
        exit 1
    fi
    
    # Update config
    if command -v jq &> /dev/null; then
        local temp_config=$(mktemp)
        jq ".components += [\"$component\"] | .components |= unique" "$CONFIG_FILE" > "$temp_config"
        mv "$temp_config" "$CONFIG_FILE"
    fi
    
    print_success "Component '$component' registered!"
    echo ""
    print_info "To use this component, add this line to your preamble (or main.tex):"
    echo ""
    echo "  \\input{\\latexKitPath/../../components/${component}.tex}"
    echo ""
    print_info "Note: We reference the shared component directly so updates apply automatically."
}

# Command: list
cmd_list() {
    print_header
    
    echo -e "${CYAN}ðŸ“¦ Available Layouts:${NC}"
    ls -1 "$REGISTRY_DIR/layouts/" | sed 's/^/  - /'
    echo ""
    
    echo -e "${CYAN}ðŸ§© Available Components:${NC}"
    ls -1 "$REGISTRY_DIR/components/" | sed 's/\.tex$//' | sed 's/^/  - /'
    echo ""
    
    if [[ -f "$CONFIG_FILE" ]]; then
        echo -e "${CYAN}âœ“ Installed Components:${NC}"
        if command -v jq &> /dev/null; then
            jq -r '.components[]' "$CONFIG_FILE" | sed 's/^/  - /'
        else
            echo "  (Install jq to see installed components)"
        fi
    fi
}

# Command: build
cmd_build() {
    if [[ ! -d "latex_source" ]]; then
        # Try to find active project
        # Try to find active project
        local active=$(get_active_project)
        if [[ -n "$active" ]]; then
            local project_dir=""
            if declare -f find_document_dir_by_id >/dev/null; then
                project_dir=$(find_document_dir_by_id "$PROJECT_ROOT" "$active")
            else
                project_dir="$PROJECT_ROOT/documents/$active"
            fi
            
            if [[ -n "$project_dir" && -d "$project_dir/latex_source" ]]; then
                print_info "Building active project: $active"
                (cd "$project_dir" && cmd_build)
                return $?
            fi
        fi

        print_error "Project not started! Run './latexkit start' first"
        exit 1
    fi
    
    print_info "Building LaTeX document..."
    
    mkdir -p build
    cd latex_source
    
    # Compile with lualatex (for fontspec support) using explicit output directory
    print_info "Pass 1: Initial compilation..."
    lualatex -output-directory=../build main.tex || {
        print_error "LaTeX compilation failed! Check ../build/main.log for details"
        cd ..
        exit 1
    }
    
    # Run biber for bibliography if any .bib file exists under zotero_export
    local bibfile
    bibfile=$(find ../zotero_export -type f -name '*.bib' 2>/dev/null | head -n 1 || true)
    if [[ -n "$bibfile" ]]; then
        print_info "Pass 2: Processing bibliography..."
        cd ../build
        biber main || print_warning "Biber encountered issues (check main.blg)"
        cd ../latex_source
        
        print_info "Pass 3: Resolving citations..."
        lualatex -output-directory=../build main.tex || {
            print_error "LaTeX compilation failed on pass 3!"
            cd ..
            exit 1
        }
        
        print_info "Pass 4: Final compilation..."
        lualatex -output-directory=../build main.tex || {
            print_error "LaTeX compilation failed on pass 4!"
            cd ..
            exit 1
        }
    fi
    
    cd ..
    
    # Verify PDF is in correct location
    if [[ -f "build/main.pdf" ]]; then
        print_success "Document compiled successfully!"
        echo ""
        print_info "Output: build/main.pdf"
        
        # Warn if PDF exists in wrong location
        if [[ -f "latex_source/main.pdf" ]]; then
            print_warning "PDF also found in latex_source/ (wrong location)"
            print_info "This should not happen with correct compilation"
        fi
    else
        print_error "PDF was not generated!"
        if [[ -f "latex_source/main.pdf" ]]; then
            print_error "PDF found in latex_source/ instead of build/"
            print_error "This indicates a compilation issue"
        fi
        print_info "Check build/main.log for details"
        exit 1
    fi
}

# Command: clean
cmd_clean() {
    if [[ ! -d "build" ]] && [[ ! -d "latex_source" ]]; then
        # Try to find active project
        # Try to find active project
        local active=$(get_active_project)
        if [[ -n "$active" ]]; then
            local project_dir=""
            if declare -f find_document_dir_by_id >/dev/null; then
                project_dir=$(find_document_dir_by_id "$PROJECT_ROOT" "$active")
            else
                project_dir="$PROJECT_ROOT/documents/$active"
            fi

            if [[ -n "$project_dir" && -d "$project_dir" ]]; then
                print_info "Cleaning active project: $active"
                (cd "$project_dir" && cmd_clean)
                return $?
            fi
        fi
    fi

    print_info "Cleaning build artifacts..."
    rm -rf build/
    print_success "Build directory cleaned"
}

# Command: commit (smart git commit with workflow labels)
cmd_commit() {
    local commit_script="$SCRIPT_DIR/scripts/bash/smart-commit.sh"
    
    if [[ ! -x "$commit_script" ]]; then
        print_error "Smart commit script not found or not executable!"
        print_info "Expected: $commit_script"
        exit 1
    fi
    
    # Pass all arguments to the smart-commit script
    "$commit_script" "$@"
}

# =================================================================
# MAIN-ONLY WORKFLOW COMMANDS
# =================================================================

# Command: new (create a new project in documents/)
# Usage: ./latexkit new "Project Description" [--layout academic-assignment] [--semester <name>]
cmd_new() {
    print_header
    
    local description=""
    local layout="academic-assignment"
    local short_name=""
    local semester=""
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            --layout)
                layout="$2"
                shift 2
                ;;
            --short-name)
                short_name="$2"
                shift 2
                ;;
            --semester)
                semester="$2"
                shift 2
                ;;
            *)
                if [[ -z "$description" ]]; then
                    description="$1"
                fi
                shift
                ;;
        esac
    done
    
    if [[ -z "$description" ]]; then
        print_error "Please provide a project description"
        echo "Usage: ./latexkit new \"Your Project Description\" [--layout academic-assignment] [--semester <name>]"
        exit 1
    fi
    
    # Check if layout exists
    if [[ ! -d "$REGISTRY_DIR/layouts/$layout" ]]; then
        print_error "Layout '$layout' not found!"
        echo ""
        echo "Available layouts:"
        ls -1 "$REGISTRY_DIR/layouts/" | sed 's/^/  - /'
        exit 1
    fi
    
    # Semester Logic
    
    if [[ -z "$semester" ]]; then
        # 1. Try to read the last used semester from workspace state
        # This makes the CLI feel "sticky" and smart.
        semester=$(get_workspace_state "LAST_SEMESTER")
        
        # 2. Fallback: Auto-detect the latest semester folder
        # If no state is found, we look at the filesystem to guess where the user is working.
        if [[ -z "$semester" ]]; then
            local docs_dir="$PROJECT_ROOT/documents"
            if [[ -d "$docs_dir" ]]; then
                local candidates=()
                # Use glob expansion safely
                local found_dirs=("$docs_dir"/*)
                if [[ -e "${found_dirs[0]}" ]]; then
                    for dir in "${found_dirs[@]}"; do
                        if [[ -d "$dir" ]]; then
                            local dirname=$(basename "$dir")
                            # Check if it looks like a semester (not a project)
                            if [[ ! "$dirname" =~ ^\. && ! -f "$dir/start.md" && ! -f "$dir/latexkit.config.json" ]]; then
                                candidates+=("$dirname")
                            fi
                        fi
                    done
                fi
                
                # Sort candidates reverse to get latest
                if [[ ${#candidates[@]} -gt 0 ]]; then
                    IFS=$'\n' sorted=($(sort -r <<<"${candidates[*]}"))
                    unset IFS
                    semester="${sorted[0]}"
                    print_info "Auto-detected semester: $semester"
                fi
            fi
        fi

        if [[ -n "$semester" ]]; then
            print_info "Using semester: $semester (use --semester to override)"
        fi
    fi

    # Always update state to ensure stickiness
    # We save this choice so the next command defaults to this semester.
    if [[ -n "$semester" ]]; then
        set_workspace_state "LAST_SEMESTER" "$semester"
    fi
    
    echo -e "${CYAN}Creating new project: ${description}${NC}"
    if [[ -n "$semester" ]]; then
        echo -e "${BLUE}Semester: ${semester}${NC}"
    fi
    echo ""
    
    # Determine documents root for this project
    local docs_root="$PROJECT_ROOT/documents"
    if [[ -n "$semester" ]]; then
        docs_root="$PROJECT_ROOT/documents/$semester"
    fi
    
    # Ensure documents directory exists
    mkdir -p "$docs_root"
    
    # Generate project slug
    local slug=""
    if [[ -n "$short_name" ]]; then
        slug=$(echo "$short_name" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9]/-/g' | sed 's/-\+/-/g; s/^-//; s/-$//')
    else
        # Use generate_concise_slug if available
        if command -v generate_concise_slug &>/dev/null || declare -f generate_concise_slug &>/dev/null; then
            slug=$(generate_concise_slug "$description")
        else
            # Fallback: simple slug generation
            slug=$(echo "$description" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9]/-/g' | sed 's/-\+/-/g; s/^-//; s/-$//' | cut -c1-48)
        fi
    fi
    
    local project_id="${slug}"
    

    local project_dir="$docs_root/$project_id"
    
    print_info "Project ID: $project_id"
    
    # Create project directory structure
    mkdir -p "$project_dir"/{checklists,latex_source/{sections,images},build,assignment_info,zotero_export}
    mkdir -p "$project_dir"/generated_work/{research,outlines,drafts,conversion,compilation,reviews}
    
    # Add .gitkeep files to preserve empty directories
    for dir in "$project_dir"/build "$project_dir"/assignment_info "$project_dir"/zotero_export "$project_dir"/checklists \
               "$project_dir"/generated_work/{research,outlines,drafts,conversion,compilation,reviews}; do
        touch "$dir/.gitkeep"
    done
    
    # Copy layout template files
    print_info "Copying layout template: $layout"
    cp -r "$REGISTRY_DIR/layouts/$layout/sections"/* "$project_dir/latex_source/sections/" 2>/dev/null || true
    
    # Copy latexmkrc configuration
    print_info "Copying latexmkrc..."
    cp "$SCRIPT_DIR/templates/latexmkrc" "$project_dir/latex_source/.latexmkrc"
    
    # Calculate relative path to registry
    # Depth: documents/<semester>/<project>/latex_source -> 4 levels up
    # Depth: documents/<project>/latex_source -> 3 levels up
    local registry_rel_path="../../../.latexkit/registry/layouts/$layout"
    if [[ -n "$semester" ]]; then
        registry_rel_path="../../../../.latexkit/registry/layouts/$layout"
    fi
    
    # Create main.tex with template reference
    cat > "$project_dir/latex_source/main.tex" <<EOF
%!TeX root = main.tex
%% LATEXKIT CONFIGURATION
%% This path points to the shared template registry.
\\newcommand{\\latexKitPath}{$registry_rel_path}

$(cat "$REGISTRY_DIR/layouts/$layout/main.tex")
EOF
    
    # Patch preamble input to use latexKitPath
    sed -i '' 's|\\input{preamble.tex}|\\input{\\latexKitPath/preamble.tex}|g' "$project_dir/latex_source/main.tex"
    
    # Create basic start.md
    local today=$(date +%Y-%m-%d)
    cat > "$project_dir/start.md" <<EOF
# Project Start File: $description

**Document ID**: \`$project_id\`  
**Created**: \`$today\`  
**Status**: \`Draft\`
EOF
    if [[ -n "$semester" ]]; then
        echo "**Semester**: \`$semester\`" >> "$project_dir/start.md"
    fi
    cat >> "$project_dir/start.md" <<EOF

---

## Executive Summary

### Purpose
$description

### Type
**Document Type**: \`Assignment\`

### Document Output Language
**Final Document Language**: \`Indonesian\`

### Key Requirements
1. [Requirement 1]
2. [Requirement 2]
3. [Requirement 3]

---

## Notes

<!-- Add project notes here -->
EOF

    # Create project-level config file
    cat > "$project_dir/latexkit.config.json" <<EOF
{
  "project": {
    "name": "$description",
    "layout": "$layout",
    "language": "indonesian",
    "semester": "$semester"
  },
  "components": [],
  "style": {
    "font": "Times New Roman",
    "fontSize": "12pt",
    "lineSpacing": 1.5,
    "margin": "1in"
  },
  "paths": {
    "source": "latex_source",
    "output": "build",
    "bibliography": "zotero_export"
  }
}
EOF
    
    # Set as active project
    # Set as active project
    set_workspace_state "ACTIVE_PROJECT" "$project_id"
    
    print_success "Project created: $project_dir"
    echo ""
    echo -e "${GREEN}Project '$project_id' is now active!${NC}"
    echo ""
    echo "Next steps:"
    echo "  1. Edit $project_dir/start.md with project details"
    echo "  2. Run './latexkit start' to generate an AI Agent Prompt"
    echo "  3. Or use ./latexkit build to compile"
    echo ""
    echo "Switch projects anytime with: ./latexkit switch $project_id"
}

# Command: switch (change active project)
# Usage: ./latexkit switch <project_id|project_num>
cmd_switch() {
    local project_id="$1"
    
    if [[ -z "$project_id" ]]; then
        # Show project list and prompt
        echo -e "${CYAN}Available projects:${NC}"
        echo ""
        
        if declare -f list_projects >/dev/null; then
            list_projects
        else
            # Fallback listing
            local active=$(get_active_project)
            for dir in "$PROJECT_ROOT/documents"/*; do
                if [[ -d "$dir" ]]; then
                    local dirname=$(basename "$dir")
                    if [[ ! "$dirname" =~ ^\. ]]; then
                        if [[ "$dirname" == "$active" ]]; then
                            echo -e "  ${GREEN}*${NC} $dirname ${GREEN}(active)${NC}"
                        else
                            echo "    $dirname"
                        fi
                    fi
                fi
            done
        fi
        
        echo ""
        read -p "Enter project number or ID to switch to: " -r project_id
        echo ""
        
        if [[ -z "$project_id" ]]; then
            print_info "Switch cancelled"
            exit 0
        fi
    fi
    
    # Use shared logic to find project directory
    local project_dir=""
    if declare -f find_document_dir_by_id >/dev/null; then
        project_dir=$(find_document_dir_by_id "$PROJECT_ROOT" "$project_id")
    else
        # Fallback logic (non-recursive)
        if [[ "$project_id" =~ ^[0-9]+$ ]]; then
            local padded=$(printf "%03d" "$((10#$project_id))")
            for dir in "$PROJECT_ROOT/documents"/"$padded"-*; do
                if [[ -d "$dir" ]]; then
                    project_dir="$dir"
                    break
                fi
            done
        else
            if [[ -d "$PROJECT_ROOT/documents/$project_id" ]]; then
                project_dir="$PROJECT_ROOT/documents/$project_id"
            fi
        fi
    fi
    
    # Validate project exists
    if [[ -z "$project_dir" || ! -d "$project_dir" ]]; then
        print_error "Project not found: $project_id"
        exit 1
    fi
    
    # Get actual project ID from directory name
    local real_project_id=$(basename "$project_dir")
    
    # Set active project
    # Set active project
    set_workspace_state "ACTIVE_PROJECT" "$real_project_id"
    print_success "Switched to project: $real_project_id"
    
    # Show project info
    local start_file="$project_dir/start.md"
    if [[ -f "$start_file" ]]; then
        local title=$(head -5 "$start_file" | grep "^# " | head -1 | sed 's/^# //')
        if [[ -n "$title" ]]; then
            echo ""
            print_info "Project: $title"
        fi
        
        # Show semester if available
        local semester=$(grep "^\*\*Semester\*\*:" "$start_file" | cut -d'`' -f2)
        if [[ -n "$semester" ]]; then
            print_info "Semester: $semester"
        fi
    fi
}

# Command: projects (list all projects)
cmd_projects() {
    print_header
    
    echo -e "${CYAN}ðŸ“ Projects in documents/:${NC}"
    echo ""
    
    # Use shared listing logic from common.sh
    if declare -f list_projects >/dev/null; then
        list_projects
    else
        # Fallback if common.sh not sourced or function missing
        local active=$(get_active_project)
        for dir in "$PROJECT_ROOT/documents"/*; do
            if [[ -d "$dir" ]]; then
                local dirname=$(basename "$dir")
                if [[ ! "$dirname" =~ ^\. ]]; then
                    if [[ "$dirname" == "$active" ]]; then
                        echo -e "  ${GREEN}*${NC} $dirname ${GREEN}(active)${NC}"
                    else
                        echo "    $dirname"
                    fi
                fi
            fi
        done
    fi
    
    echo ""
    echo "Commands:"
    echo "  ./latexkit switch <num>  Switch to a project (e.g., ./latexkit switch 1)"
    echo "  ./latexkit new \"desc\"    Create a new project"
}

# Command: current (show current active project)
cmd_current() {
    local active=$(get_active_project)
    
    if [[ -z "$active" ]]; then
        print_warning "No active project"
        echo ""
        echo "Set an active project:"
        echo "  ./latexkit switch <project_id>"
        echo "  ./latexkit new \"Project Description\""
        exit 0
    fi
    
    echo -e "${CYAN}Active project:${NC} $active"
    
    local project_dir=""
    if declare -f find_document_dir_by_id >/dev/null; then
        project_dir=$(find_document_dir_by_id "$PROJECT_ROOT" "$active")
    fi
    
    if [[ -z "$project_dir" ]]; then
        # Fallback
        project_dir="$PROJECT_ROOT/documents/$active"
    fi
    local start_file="$project_dir/start.md"
    
    if [[ -f "$start_file" ]]; then
        local title=$(head -5 "$start_file" | grep "^# " | head -1 | sed 's/^# Project Start File: //')
        if [[ -n "$title" ]]; then
            echo "Title: $title"
        fi
    fi
    
    echo ""
    echo "Project path: $project_dir"
}

# Command: reset (destructive clean - strips to template)
# Command: reset (destructive clean - strips to template)
cmd_reset() {
    print_header
    
    echo -e "${RED}âš ï¸  WARNING: DESTRUCTIVE OPERATION âš ï¸${NC}"
    echo ""
    
    echo -e "${CYAN}What would you like to reset?${NC}"
    echo "  [1] Active Project (Reset to template state, keep start.md/config)"
    echo "  [2] All Projects (Delete everything in documents/)"
    echo "  [3] Cancel"
    echo ""
    read -p "Select option [1-3]: " -r scope_choice
    echo ""
    
    if [[ "$scope_choice" == "3" ]]; then
        print_info "Reset cancelled"
        exit 0
    fi
    
    if [[ "$scope_choice" == "1" ]]; then
        # Reset active project
        local active=$(get_active_project)
        
        if [[ -z "$active" ]]; then
            print_error "No active project found."
            exit 1
        fi
        
        local project_dir=""
        if declare -f find_document_dir_by_id >/dev/null; then
            project_dir=$(find_document_dir_by_id "$PROJECT_ROOT" "$active")
        else
            project_dir="$PROJECT_ROOT/documents/$active"
        fi
        
        if [[ -z "$project_dir" || ! -d "$project_dir" ]]; then
            print_error "Project directory not found for: $active"
            exit 1
        fi
        
        echo -e "${YELLOW}This will:${NC}"
        echo "  â€¢ COMPLETELY DELETE the project folder: $project_dir"
        echo "  â€¢ Revert .latexkit-workspace to last commit (if changed)"
        echo ""
        echo -e "${RED}This action CANNOT be undone!${NC}"
        echo ""
        read -p "Type 'RESET' to confirm: " -r
        echo
        
        if [[ "$REPLY" != "RESET" ]]; then
            print_info "Reset cancelled"
            exit 0
        fi
        
        # Execute reset
        print_info "Removing project directory..."
        rm -rf "$project_dir"
        
        # Revert workspace state if modified
        local workspace_file="$PROJECT_ROOT/.latexkit-workspace"
        if [[ -f "$workspace_file" ]]; then
            if git -C "$PROJECT_ROOT" diff --quiet "$workspace_file"; then
                print_info ".latexkit-workspace is clean, no revert needed."
            else
                print_info "Reverting .latexkit-workspace to last commit..."
                git -C "$PROJECT_ROOT" checkout "$workspace_file" 2>/dev/null || git -C "$PROJECT_ROOT" restore "$workspace_file" 2>/dev/null || print_warning "Failed to revert workspace file (git might not be initialized or file is new)"
            fi
        fi
        
        print_success "Project '$active' removed and workspace reset."
        
    elif [[ "$scope_choice" == "2" ]]; then
        # Reset all projects
        
        echo -e "${YELLOW}This will PERMANENTLY DELETE:${NC}"
        echo "  â€¢ The entire 'documents/' directory"
        echo "  â€¢ All projects and work within it"
        echo ""
        echo -e "${RED}This action CANNOT be undone!${NC}"
        echo ""
        read -p "Type 'RESET' to confirm: " -r
        echo
        
        if [[ "$REPLY" != "RESET" ]]; then
            print_info "Reset cancelled"
            exit 0
        fi
        
        # Delete all projects
        print_info "Deleting all projects..."
        rm -rf "$PROJECT_ROOT/documents"
        mkdir -p "$PROJECT_ROOT/documents"
        
        # Clear active project
        set_workspace_state "ACTIVE_PROJECT" ""
        
        print_success "All projects deleted. documents/ directory is clean."
        
    else
        print_error "Invalid option selected"
        exit 1
    fi
}

# Command: help
# Command: prompt (generate context prompt)
cmd_prompt() {
    local script="$SCRIPT_DIR/scripts/bash/gen-prompt.sh"
    if [[ ! -x "$script" ]]; then
        print_error "Prompt generator script not found or not executable!"
        print_info "Expected: $script"
        exit 1
    fi
    "$script" "$@"
}

cmd_help() {
    print_header
    echo "Usage: ./latexkit <command> [options]"
    echo ""
    echo -e "${CYAN}Project Management (Main-Only Workflow):${NC}"
    echo "  new \"description\"       Create a new project in documents/"
    echo "  switch <id|num>         Switch active project (e.g., switch 1 or switch 001-my-project)"
    echo "  projects                List all projects"
    echo "  current                 Show current active project"
    echo ""
    echo -e "${CYAN}LaTeX Template Commands:${NC}"
    echo "  start [--layout <name>] Initialize LaTeX template in current directory"
    echo "  add <component>         Add a component to your project"
    echo "  list                    List available layouts and components"
    echo "  build                   Compile the LaTeX document"
    echo "  clean                   Remove build artifacts"
    echo ""
    echo -e "${CYAN}Git Integration:${NC}"
    echo "  commit [stage] [opts]   Smart git commit with workflow labels"
    echo "  reset                   ðŸ”¥ Reset projects (DESTRUCTIVE)"
    echo ""
    echo "  help                    Show this help message"
    echo ""
    echo -e "${CYAN}Examples:${NC}"
    echo "  ./latexkit new \"Essay Sejarah Indonesia\"   # Create new project"
    echo "  ./latexkit switch 1                         # Switch to project 001"
    echo "  ./latexkit projects                         # List all projects"
    echo "  ./latexkit build                            # Compile current project"
    echo "  ./latexkit commit research                  # Commit with RESEARCH label"
}

# Main command router
main() {
    if [[ $# -eq 0 ]]; then
        cmd_help
        exit 0
    fi
    
    case $1 in
        init)
            shift
            cmd_init "$@"
            ;;
        start)
            shift
            cmd_start "$@"
            ;;
        new)
            shift
            cmd_new "$@"
            ;;
        add)
            shift
            cmd_add "$@"
            ;;
        list)
            shift
            cmd_list "$@"
            ;;
        build)
            shift
            cmd_build "$@"
            ;;
        clean)
            shift
            cmd_clean "$@"
            ;;
        commit)
            shift
            cmd_commit "$@"
            ;;
        switch)
            shift
            cmd_switch "$@"
            ;;
        projects)
            shift
            cmd_projects "$@"
            ;;
        reset)
            shift
            cmd_reset "$@"
            ;;
        help|--help|-h)
            print_header
            echo "Usage: ./latexkit <command> [options]"
            echo ""
            echo "Commands:"
            echo "  new      Create a new project in documents/"
            echo "  start    Generate an AI Agent Prompt for the current project"
            echo "  init     Initialize the current folder as a LaTeXKit project"
            echo "  switch   Switch active project context"
            echo "  projects List all projects"
            echo "  add      Add a component to the current project"
            echo "  list     List available layouts and components"
            echo "  build    Build the current project"
            echo "  clean    Clean build artifacts"
            echo "  commit   Smart commit with conventional messages"
            echo "  reset    Reset project state (dangerous)"
            echo ""
            ;;
        *)
            print_error "Unknown command: $1"
            echo "Run './latexkit help' for usage"
            exit 1
            ;;
    esac
}

main "$@"
