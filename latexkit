#!/usr/bin/env bash
# LaTeXKit CLI - Component-based LaTeX template manager
# Inspired by shadcn/ui
#
# MAIN-ONLY WORKFLOW:
# This CLI supports trunk-based development (all work on main branch).
# Projects are managed via `documents/` folder and `.latexkit-workspace` state file.

set -e

# =================================================================
# ARCHITECTURE OVERVIEW: SUPER REPO VS STANDALONE
# =================================================================
# This script is designed to work in two distinct architectural contexts:
#
# 1. STANDALONE MODE (Repo A)
#    - The standard usage where you clone this repo and use it directly.
#    - The "Project Root" is simply the root of this git repository.
#    - Documents live in `documents/` relative to this script.
#
# 2. SUBMODULE MODE (Repo B / Super Repo)
#    - The advanced usage where this repo is a submodule inside a larger "Super Repo".
#    - The "Project Root" is the root of the Super Repo (Repo B), NOT this submodule.
#    - This allows you to have a private "Work Repo" that pulls in this public "Template Repo".
#    - We detect this mode automatically via git or explicit environment variables.
#
# Why this matters:
# - All git operations (commits, diffs) must run from the Project Root.
# - Path resolution for `documents/` must be relative to the Project Root.
# =================================================================

VERSION="1.1.0"
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# OPERATION MODE DETECTION (The Smart Logic)
# -----------------------------------------------------------
# This section determines how the script is being run and sets the project root accordingly.
# It's crucial for supporting both standalone usage and submodule integration.

# Check 1: Is there an Environment Variable from a Wrapper? (Explicit override)
# If a parent script (like a wrapper in a Super Repo) sets this, we trust it blindly.
if [[ -n "${LATEXKIT_SUPER_REPO_ROOT:-}" ]]; then
    PROJECT_ROOT="$LATEXKIT_SUPER_REPO_ROOT"
    MODE="Submodule (Wrapper)"

# Check 2: Am I inside a Git Superproject? (Native Git check)
# This command returns the path to the Super Repo (Repo B) if this script is running inside a submodule.
# It's a robust way to detect if we are just a component in a larger system.
elif SUPER_ROOT=$(git -C "$SCRIPT_DIR" rev-parse --show-superproject-working-tree 2>/dev/null) && [[ -n "$SUPER_ROOT" ]]; then
    PROJECT_ROOT="$SUPER_ROOT"
    MODE="Submodule (Native)"

# Check 3: Fallback to Standalone (Direct Clone)
# If neither of the above, we assume we are running as a standalone repository (Repo A).
# We use the git root of this script's location.
else
    # Use the root of this git repo itself
    PROJECT_ROOT="$(git -C "$SCRIPT_DIR" rev-parse --show-toplevel 2>/dev/null || echo "$SCRIPT_DIR")"
    MODE="Standalone"
fi

# Export agar bisa dibaca oleh child scripts (common.sh dll)
export LATEXKIT_PROJECT_ROOT="$PROJECT_ROOT"
REGISTRY_DIR="$SCRIPT_DIR/registry"
CONFIG_FILE="latexkit.config.json"



# Source common utilities
source "$SCRIPT_DIR/scripts/bash/common.sh" 2>/dev/null || true

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
MAGENTA='\033[0;35m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# Helper functions
print_header() {
    local title="LaTeXKit v${VERSION}"
    local subtitle="Component-based LaTeX Templates"
    
    # Calculate the width needed (use the longer line)
    local title_len=${#title}
    local subtitle_len=${#subtitle}
    local content_width=$((title_len > subtitle_len ? title_len : subtitle_len))
    
    # Add padding (4 spaces on each side)
    local total_width=$((content_width + 8))
    
    # Generate horizontal borders dynamically
    local horizontal_border=$(printf '‚ïê%.0s' $(seq 1 $total_width))
    
    # Calculate padding for centering
    local title_padding=$(( (total_width - title_len) / 2 ))
    local subtitle_padding=$(( (total_width - subtitle_len) / 2 ))
    
    echo -e "${MAGENTA}"
    echo "‚ïî${horizontal_border}‚ïó"
    printf "‚ïë%*s%s%*s‚ïë\n" $title_padding "" "$title" $((total_width - title_len - title_padding)) ""
    printf "‚ïë%*s%s%*s‚ïë\n" $subtitle_padding "" "$subtitle" $((total_width - subtitle_len - subtitle_padding)) ""
    echo "‚ïö${horizontal_border}‚ïù"
    echo -e "${NC}"
}

print_success() {
    echo -e "${GREEN}‚úì${NC} $1"
}

print_error() {
    echo -e "${RED}‚úó${NC} $1"
}

print_info() {
    echo -e "${BLUE}‚Ñπ${NC} $1"
}

print_warning() {
    echo -e "${YELLOW}‚ö†${NC} $1"
}

# Command: init (formerly start)
# Command: plan (Generate AI Prompt)
cmd_plan() {
    # Includes assignment info + configuration + brief
    generate_prompt_from_template "latexkit.plan.prompt.md"
}

# Command: start (Generate AI Prompt)


# Command: add
cmd_add() {
    local component="$1"
    
    if [[ -z "$component" ]]; then
        print_error "Please specify a component to add"
        echo "Usage: ./latexkit add <component>"
        echo ""
        echo "Available components:"
        ls -1 "$REGISTRY_DIR/components/" | sed 's/\.tex$//' | sed 's/^/  - /'
        exit 1
    fi
    
    # Check if project is started
    if [[ ! -d "latex_source" ]]; then
        print_error "Project not started! Run './latexkit start' first"
        exit 1
    fi
    
    # Check if component exists
    if [[ ! -f "$REGISTRY_DIR/components/${component}.tex" ]]; then
        print_error "Component '$component' not found!"
        echo ""
        echo "Available components:"
        ls -1 "$REGISTRY_DIR/components/" | sed 's/\.tex$//' | sed 's/^/  - /'
        exit 1
    fi
    
    # Update config
    if command -v jq &> /dev/null; then
        local temp_config=$(mktemp)
        jq ".components += [\"$component\"] | .components |= unique" "$CONFIG_FILE" > "$temp_config"
        mv "$temp_config" "$CONFIG_FILE"
    fi
    
    print_success "Component '$component' registered!"
    echo ""
    print_info "To use this component, add this line to your preamble (or main.tex):"
    echo ""
    echo "  \\input{\\latexKitPath/../../components/${component}.tex}"
    echo ""
    print_info "Note: We reference the shared component directly so updates apply automatically."
}

# Command: list
cmd_list() {
    print_header
    
    echo -e "${CYAN}üì¶ Available Layouts:${NC}"
    ls -1 "$REGISTRY_DIR/layouts/" | sed 's/^/  - /'
    echo ""
    
    echo -e "${CYAN}üß© Available Components:${NC}"
    ls -1 "$REGISTRY_DIR/components/" | sed 's/\.tex$//' | sed 's/^/  - /'
    echo ""
    
    if [[ -f "$CONFIG_FILE" ]]; then
        echo -e "${CYAN}‚úì Installed Components:${NC}"
        if command -v jq &> /dev/null; then
            jq -r '.components[]' "$CONFIG_FILE" | sed 's/^/  - /'
        else
            echo "  (Install jq to see installed components)"
        fi
    fi
}

# =================================================================
# PROMPT GENERATION ENGINE & WORKFLOW COMMANDS
# =================================================================

# Shared function to generate "Context-Aware" prompts
# Usage: generate_prompt "template_name" "additional_context_files..."
generate_prompt_from_template() {
    local template_name="$1"
    shift
    local context_files=("$@")

    print_header
    echo -e "${CYAN}Generating AI Agent Prompt for: ${template_name}${NC}"
    echo ""

    # Check for active project
    if [[ ! -f "latexkit.config.json" ]]; then
        # Try to switch to active project
        local active=$(get_active_project)
        if [[ -n "$active" ]]; then
            local project_dir=""
             if declare -f find_document_dir_by_id >/dev/null; then
                project_dir=$(find_document_dir_by_id "$PROJECT_ROOT" "$active")
            else
                project_dir="$PROJECT_ROOT/documents/$active"
            fi
            
            if [[ -n "$project_dir" && -d "$project_dir" ]]; then
                print_info "Switching context to active project: $active"
                # Recursively call the calling function (e.g., cmd_research) in the correct dir
                (cd "$project_dir" && "$FUNCNAME" "$template_name" "${context_files[@]}")
                return $?
            fi
        fi
        print_error "No active project found! Run inside a project folder or select one."
        exit 1
    fi

    # 1. Load Project Metadata
    local project_name="Untitled Project"
    local config_content="{}"
    if command -v jq &> /dev/null; then
        project_name=$(jq -r '.project.name // "Untitled Project"' latexkit.config.json)
        config_content=$(cat latexkit.config.json)
    elif [[ -f "latexkit.config.json" ]]; then
         config_content=$(cat latexkit.config.json)
    fi

    local start_content="(No start.md found)"
    [[ -f "start.md" ]] && start_content=$(cat "start.md")

    # 2. Gather Context Files (Assignment Info is ALWAYS included)
    local assignment_context=""
    if [[ -d "assignment_info" ]]; then
        assignment_context=$(find assignment_info -type f -not -name '.gitkeep' 2>/dev/null | sed 's/^/   - /')
    fi
    [[ -z "$assignment_context" ]] && assignment_context="   (No context files found in assignment_info)"

    # 3. Gather Additional Context (Specific to the step)
    local specific_context=""
    for pattern in "${context_files[@]}"; do
        # Handle globbing manually since it's passed as a string
        # We assume the pattern is relative to project root
        if compgen -G "$pattern" > /dev/null; then
            for f in $pattern; do
                 specific_context+=$'\n   - '"$f"
            done
        fi
    done
    [[ -z "$specific_context" ]] && specific_context="   (No specific context files found for this step)"

    # 4. Load the Template
    # We look in the .latexkit submodule location primarily
    local template_path="$PROJECT_ROOT/.latexkit/.github/prompts/${template_name}"
    
    # Fallback: if running standalone
    if [[ ! -f "$template_path" ]]; then
        template_path="$SCRIPT_DIR/.github/prompts/${template_name}"
    fi

    if [[ ! -f "$template_path" ]]; then
        print_warning "Template '$template_name' not found at $template_path"
        print_info "Using a generic prompt fallback."
        template_path=$(mktemp)
        echo "# Task: $template_name" > "$template_path"
        echo "Please help me with the $template_name phase of this project." >> "$template_path"
    fi

    local template_content=$(cat "$template_path")

    # 5. Construct the Final Prompt
    local prompt_file=$(mktemp)

    cat > "$prompt_file" <<EOF
You are an AI assistant helping with a LaTeX project.

# Project Context
**Project Name**: $project_name
**Path**: $(pwd)

## Configuration
\`\`\`json
$config_content
\`\`\`

## Project Brief
\`\`\`markdown
$start_content
\`\`\`

## Assignment Context (Global)
**CRITICAL**: You must read these files to understand the requirements.
$assignment_context

## Stage-Specific Context
The following files are relevant to this specific stage ($template_name):
$specific_context

## Directory Structure
\`\`\`
$(ls -R | grep ":$" | head -n 20 | sed 's/:$//' | sed 's/[^-][^\/]*\//--/g' | sed 's/^/   /' | sed 's/-/|/')
(truncated)
\`\`\`

---
# INSTRUCTIONS

$template_content
EOF

    # Output to user
    echo -e "${YELLOW}--- COPY THE PROMPT BELOW ---${NC}"
    cat "$prompt_file"
    echo -e "${YELLOW}-----------------------------${NC}"
    
    # Optional: Copy to clipboard (macOS only)
    if command -v pbcopy &> /dev/null; then
        cat "$prompt_file" | pbcopy
        echo ""
        print_success "Prompt copied to clipboard!"
    fi
    
    rm "$prompt_file"
}

# -----------------------------------------------------------------
# 1. PLAN (formerly start)
# -----------------------------------------------------------------
# cmd_plan is defined above.


# -----------------------------------------------------------------
# 2. RESEARCH
# -----------------------------------------------------------------
cmd_research() {
    # Includes assignment info + any existing research notes
    generate_prompt_from_template "latexkit.research.prompt.md" "generated_work/research/*.md"
}

# -----------------------------------------------------------------
# 3. OUTLINE
# -----------------------------------------------------------------
cmd_outline() {
    # Includes research notes
    generate_prompt_from_template "latexkit.outline.prompt.md" "generated_work/research/*.md"
}

# -----------------------------------------------------------------
# 4. DRAFT
# -----------------------------------------------------------------
cmd_draft() {
    # Includes the outline + research
    generate_prompt_from_template "latexkit.draft.prompt.md" "generated_work/outlines/*.md" "generated_work/research/*.md"
}

# -----------------------------------------------------------------
# 5. CONVERT
# -----------------------------------------------------------------
cmd_convert() {
    # Includes the draft text
    generate_prompt_from_template "latexkit.convert.prompt.md" "generated_work/drafts/*.md"
}

# -----------------------------------------------------------------
# TOOLS (Build, Check, Commit)
# -----------------------------------------------------------------

cmd_check() {
    # Includes build logs or latex source
    generate_prompt_from_template "latexkit.check.prompt.md" "latex_source/main.log" "latex_source/*.tex"
}

# Command: build
cmd_build() {
    if [[ ! -d "latex_source" ]]; then
        # Try to find active project
        # Try to find active project
        local active=$(get_active_project)
        if [[ -n "$active" ]]; then
            local project_dir=""
            if declare -f find_document_dir_by_id >/dev/null; then
                project_dir=$(find_document_dir_by_id "$PROJECT_ROOT" "$active")
            else
                project_dir="$PROJECT_ROOT/documents/$active"
            fi
            
            if [[ -n "$project_dir" && -d "$project_dir/latex_source" ]]; then
                print_info "Building active project: $active"
                (cd "$project_dir" && cmd_build)
                return $?
            fi
        fi

        print_error "Project not started! Run './latexkit start' first"
        exit 1
    fi
    
    print_info "Building LaTeX document..."
    
    mkdir -p build
    cd latex_source
    
    # Compile with lualatex (for fontspec support) using explicit output directory
    print_info "Pass 1: Initial compilation..."
    lualatex -output-directory=../build main.tex || {
        print_error "LaTeX compilation failed! Check ../build/main.log for details"
        cd ..
        exit 1
    }
    
    # Run biber for bibliography if any .bib file exists under zotero_export
    local bibfile
    bibfile=$(find ../zotero_export -type f -name '*.bib' 2>/dev/null | head -n 1 || true)
    if [[ -n "$bibfile" ]]; then
        print_info "Pass 2: Processing bibliography..."
        cd ../build
        biber main || print_warning "Biber encountered issues (check main.blg)"
        cd ../latex_source
        
        print_info "Pass 3: Resolving citations..."
        lualatex -output-directory=../build main.tex || {
            print_error "LaTeX compilation failed on pass 3!"
            cd ..
            exit 1
        }
        
        print_info "Pass 4: Final compilation..."
        lualatex -output-directory=../build main.tex || {
            print_error "LaTeX compilation failed on pass 4!"
            cd ..
            exit 1
        }
    fi
    
    cd ..
    
    # Verify PDF is in correct location
    if [[ -f "build/main.pdf" ]]; then
        print_success "Document compiled successfully!"
        echo ""
        print_info "Output: build/main.pdf"
        
        # Warn if PDF exists in wrong location
        if [[ -f "latex_source/main.pdf" ]]; then
            print_warning "PDF also found in latex_source/ (wrong location)"
            print_info "This should not happen with correct compilation"
        fi
    else
        print_error "PDF was not generated!"
        if [[ -f "latex_source/main.pdf" ]]; then
            print_error "PDF found in latex_source/ instead of build/"
            print_error "This indicates a compilation issue"
        fi
        print_info "Check build/main.log for details"
        exit 1
    fi
}

# Command: clean
cmd_clean() {
    if [[ ! -d "build" ]] && [[ ! -d "latex_source" ]]; then
        # Try to find active project
        # Try to find active project
        local active=$(get_active_project)
        if [[ -n "$active" ]]; then
            local project_dir=""
            if declare -f find_document_dir_by_id >/dev/null; then
                project_dir=$(find_document_dir_by_id "$PROJECT_ROOT" "$active")
            else
                project_dir="$PROJECT_ROOT/documents/$active"
            fi

            if [[ -n "$project_dir" && -d "$project_dir" ]]; then
                print_info "Cleaning active project: $active"
                (cd "$project_dir" && cmd_clean)
                return $?
            fi
        fi
    fi

    print_info "Cleaning build artifacts..."
    rm -rf build/
    print_success "Build directory cleaned"
}

# Command: commit (smart git commit with workflow labels)
cmd_commit() {
    local commit_script="$SCRIPT_DIR/scripts/bash/smart-commit.sh"
    
    if [[ ! -x "$commit_script" ]]; then
        print_error "Smart commit script not found or not executable!"
        print_info "Expected: $commit_script"
        exit 1
    fi
    
    # Pass all arguments to the smart-commit script
    "$commit_script" "$@"
}

# =================================================================
# MAIN-ONLY WORKFLOW COMMANDS
# =================================================================

# Command: new (create a new project in documents/)
# Usage: ./latexkit new "Project Description" [--layout academic-assignment] [--semester <name>]
cmd_new() {
    print_header
    
    local description=""
    local layout="academic-assignment"
    local short_name=""
    local semester=""
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            --layout)
                layout="$2"
                shift 2
                ;;
            --short-name)
                short_name="$2"
                shift 2
                ;;
            --semester)
                semester="$2"
                shift 2
                ;;
            *)
                if [[ -z "$description" ]]; then
                    description="$1"
                fi
                shift
                ;;
        esac
    done
    
    if [[ -z "$description" ]]; then
        print_error "Please provide a project description"
        echo "Usage: ./latexkit new \"Your Project Description\" [--layout academic-assignment] [--semester <name>]"
        exit 1
    fi
    
    # Check if layout exists
    if [[ ! -d "$REGISTRY_DIR/layouts/$layout" ]]; then
        print_error "Layout '$layout' not found!"
        echo ""
        echo "Available layouts:"
        ls -1 "$REGISTRY_DIR/layouts/" | sed 's/^/  - /'
        exit 1
    fi
    
    # Semester Logic
    
    if [[ -z "$semester" ]]; then
        # 1. Try to read the last used semester from workspace state
        # This makes the CLI feel "sticky" and smart.
        semester=$(get_workspace_state "LAST_SEMESTER")
        
        # 2. Fallback: Auto-detect the latest semester folder
        # If no state is found, we look at the filesystem to guess where the user is working.
        if [[ -z "$semester" ]]; then
            local docs_dir="$PROJECT_ROOT/documents"
            if [[ -d "$docs_dir" ]]; then
                local candidates=()
                # Use glob expansion safely
                local found_dirs=("$docs_dir"/*)
                if [[ -e "${found_dirs[0]}" ]]; then
                    for dir in "${found_dirs[@]}"; do
                        if [[ -d "$dir" ]]; then
                            local dirname=$(basename "$dir")
                            # Check if it looks like a semester (not a project)
                            if [[ ! "$dirname" =~ ^\. && ! -f "$dir/start.md" && ! -f "$dir/latexkit.config.json" ]]; then
                                candidates+=("$dirname")
                            fi
                        fi
                    done
                fi
                
                # Sort candidates reverse to get latest
                if [[ ${#candidates[@]} -gt 0 ]]; then
                    IFS=$'\n' sorted=($(sort -r <<<"${candidates[*]}"))
                    unset IFS
                    semester="${sorted[0]}"
                    print_info "Auto-detected semester: $semester"
                fi
            fi
        fi

        if [[ -n "$semester" ]]; then
            print_info "Using semester: $semester (use --semester to override)"
        fi
    fi

    # Always update state to ensure stickiness
    # We save this choice so the next command defaults to this semester.
    if [[ -n "$semester" ]]; then
        set_workspace_state "LAST_SEMESTER" "$semester"
    fi
    
    echo -e "${CYAN}Creating new project: ${description}${NC}"
    if [[ -n "$semester" ]]; then
        echo -e "${BLUE}Semester: ${semester}${NC}"
    fi
    echo ""
    
    # Determine documents root for this project
    local docs_root="$PROJECT_ROOT/documents"
    if [[ -n "$semester" ]]; then
        docs_root="$PROJECT_ROOT/documents/$semester"
    fi
    
    # Ensure documents directory exists
    mkdir -p "$docs_root"
    
    # Generate project slug
    local slug=""
    if [[ -n "$short_name" ]]; then
        slug=$(echo "$short_name" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9]/-/g' | sed 's/-\+/-/g; s/^-//; s/-$//')
    else
        # Use generate_concise_slug if available
        if command -v generate_concise_slug &>/dev/null || declare -f generate_concise_slug &>/dev/null; then
            slug=$(generate_concise_slug "$description")
        else
            # Fallback: simple slug generation
            slug=$(echo "$description" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9]/-/g' | sed 's/-\+/-/g; s/^-//; s/-$//' | cut -c1-48)
        fi
    fi
    
    local project_id="${slug}"
    

    local project_dir="$docs_root/$project_id"
    
    print_info "Project ID: $project_id"
    
    # Create project directory structure
    mkdir -p "$project_dir"/{checklists,latex_source/{sections,images},build,assignment_info,zotero_export}
    mkdir -p "$project_dir"/generated_work/{research,outlines,drafts,conversion,compilation,reviews}
    
    # Add .gitkeep files to preserve empty directories
    for dir in "$project_dir"/build "$project_dir"/assignment_info "$project_dir"/zotero_export "$project_dir"/checklists \
               "$project_dir"/generated_work/{research,outlines,drafts,conversion,compilation,reviews}; do
        touch "$dir/.gitkeep"
    done
    
    # Copy layout template files
    print_info "Copying layout template: $layout"
    cp -r "$REGISTRY_DIR/layouts/$layout/sections"/* "$project_dir/latex_source/sections/" 2>/dev/null || true
    
    # Copy latexmkrc configuration
    print_info "Copying latexmkrc..."
    cp "$SCRIPT_DIR/templates/latexmkrc" "$project_dir/latex_source/.latexmkrc"
    
    # Calculate relative path to registry
    # Depth: documents/<semester>/<project>/latex_source -> 4 levels up
    # Depth: documents/<project>/latex_source -> 3 levels up
    local registry_rel_path="../../../.latexkit/registry/layouts/$layout"
    if [[ -n "$semester" ]]; then
        registry_rel_path="../../../../.latexkit/registry/layouts/$layout"
    fi
    
    # Create main.tex with template reference
    cat > "$project_dir/latex_source/main.tex" <<EOF
%!TeX root = main.tex
%% LATEXKIT CONFIGURATION
%% This path points to the shared template registry.
\\newcommand{\\latexKitPath}{$registry_rel_path}

$(cat "$REGISTRY_DIR/layouts/$layout/main.tex")
EOF
    
    # Patch preamble input to use latexKitPath
    sed -i '' 's|\\input{preamble.tex}|\\input{\\latexKitPath/preamble.tex}|g' "$project_dir/latex_source/main.tex"
    
    # Create basic start.md
    local today=$(date +%Y-%m-%d)
    cat > "$project_dir/start.md" <<EOF
# Project Start File: $description

**Document ID**: \`$project_id\`  
**Created**: \`$today\`  
**Status**: \`Draft\`
EOF
    if [[ -n "$semester" ]]; then
        echo "**Semester**: \`$semester\`" >> "$project_dir/start.md"
    fi
    cat >> "$project_dir/start.md" <<EOF

---

## Executive Summary

### Purpose
$description

### Type
**Document Type**: \`Assignment\`

### Document Output Language
**Final Document Language**: \`Indonesian\`

### Key Requirements
1. [Requirement 1]
2. [Requirement 2]
3. [Requirement 3]

---

## Notes

<!-- Add project notes here -->
EOF

    # Create project-level config file
    cat > "$project_dir/latexkit.config.json" <<EOF
{
  "project": {
    "name": "$description",
    "layout": "$layout",
    "language": "indonesian",
    "semester": "$semester"
  },
  "components": [],
  "style": {
    "font": "Times New Roman",
    "fontSize": "12pt",
    "lineSpacing": 1.5,
    "margin": "1in"
  },
  "paths": {
    "source": "latex_source",
    "output": "build",
    "bibliography": "zotero_export"
  }
}
EOF
    
    # Set as active project
    # Set as active project
    set_workspace_state "ACTIVE_PROJECT" "$project_id"
    
    print_success "Project created: $project_dir"
    echo ""
    echo -e "${GREEN}Project '$project_id' is now active!${NC}"
    echo ""
    echo "Next steps:"
    echo "  1. Edit $project_dir/start.md with project details"
    echo "  2. Run './latexkit plan' to generate an AI Agent Prompt"
    echo "  3. Or use ./latexkit build to compile"
    echo ""
    echo "Switch projects anytime with: ./latexkit switch $project_id"
}

# Command: switch (change active project)
# Usage: ./latexkit switch <project_id|project_num>
cmd_switch() {
    local project_id="$1"
    
    if [[ -z "$project_id" ]]; then
        # Show project list and prompt
        echo -e "${CYAN}Available projects:${NC}"
        echo ""
        
        if declare -f list_projects >/dev/null; then
            list_projects
        else
            # Fallback listing
            local active=$(get_active_project)
            for dir in "$PROJECT_ROOT/documents"/*; do
                if [[ -d "$dir" ]]; then
                    local dirname=$(basename "$dir")
                    if [[ ! "$dirname" =~ ^\. ]]; then
                        if [[ "$dirname" == "$active" ]]; then
                            echo -e "  ${GREEN}*${NC} $dirname ${GREEN}(active)${NC}"
                        else
                            echo "    $dirname"
                        fi
                    fi
                fi
            done
        fi
        
        echo ""
        read -p "Enter project number or ID to switch to: " -r project_id
        echo ""
        
        if [[ -z "$project_id" ]]; then
            print_info "Switch cancelled"
            exit 0
        fi
    fi
    
    # Use shared logic to find project directory
    local project_dir=""
    if declare -f find_document_dir_by_id >/dev/null; then
        project_dir=$(find_document_dir_by_id "$PROJECT_ROOT" "$project_id")
    else
        # Fallback logic (non-recursive)
        if [[ "$project_id" =~ ^[0-9]+$ ]]; then
            local padded=$(printf "%03d" "$((10#$project_id))")
            for dir in "$PROJECT_ROOT/documents"/"$padded"-*; do
                if [[ -d "$dir" ]]; then
                    project_dir="$dir"
                    break
                fi
            done
        else
            if [[ -d "$PROJECT_ROOT/documents/$project_id" ]]; then
                project_dir="$PROJECT_ROOT/documents/$project_id"
            fi
        fi
    fi
    
    # Validate project exists
    if [[ -z "$project_dir" || ! -d "$project_dir" ]]; then
        print_error "Project not found: $project_id"
        exit 1
    fi
    
    # Get actual project ID from directory name
    local real_project_id=$(basename "$project_dir")
    
    # Set active project
    # Set active project
    set_workspace_state "ACTIVE_PROJECT" "$real_project_id"
    print_success "Switched to project: $real_project_id"
    
    # Show project info
    local start_file="$project_dir/start.md"
    if [[ -f "$start_file" ]]; then
        local title=$(head -5 "$start_file" | grep "^# " | head -1 | sed 's/^# //')
        if [[ -n "$title" ]]; then
            echo ""
            print_info "Project: $title"
        fi
        
        # Show semester if available
        local semester=$(grep "^\*\*Semester\*\*:" "$start_file" | cut -d'`' -f2)
        if [[ -n "$semester" ]]; then
            print_info "Semester: $semester"
        fi
    fi
}

# Command: projects (list all projects)
cmd_projects() {
    print_header
    
    echo -e "${CYAN}üìÅ Projects in documents/:${NC}"
    echo ""
    
    # Use shared listing logic from common.sh
    if declare -f list_projects >/dev/null; then
        list_projects
    else
        # Fallback if common.sh not sourced or function missing
        local active=$(get_active_project)
        for dir in "$PROJECT_ROOT/documents"/*; do
            if [[ -d "$dir" ]]; then
                local dirname=$(basename "$dir")
                if [[ ! "$dirname" =~ ^\. ]]; then
                    if [[ "$dirname" == "$active" ]]; then
                        echo -e "  ${GREEN}*${NC} $dirname ${GREEN}(active)${NC}"
                    else
                        echo "    $dirname"
                    fi
                fi
            fi
        done
    fi
    
    echo ""
    echo "Commands:"
    echo "  ./latexkit switch <num>  Switch to a project (e.g., ./latexkit switch 1)"
    echo "  ./latexkit new \"desc\"    Create a new project"
}

# Command: current (show current active project)
cmd_current() {
    local active=$(get_active_project)
    
    if [[ -z "$active" ]]; then
        print_warning "No active project"
        echo ""
        echo "Set an active project:"
        echo "  ./latexkit switch <project_id>"
        echo "  ./latexkit new \"Project Description\""
        exit 0
    fi
    
    echo -e "${CYAN}Active project:${NC} $active"
    
    local project_dir=""
    if declare -f find_document_dir_by_id >/dev/null; then
        project_dir=$(find_document_dir_by_id "$PROJECT_ROOT" "$active")
    fi
    
    if [[ -z "$project_dir" ]]; then
        # Fallback
        project_dir="$PROJECT_ROOT/documents/$active"
    fi
    local start_file="$project_dir/start.md"
    
    if [[ -f "$start_file" ]]; then
        local title=$(head -5 "$start_file" | grep "^# " | head -1 | sed 's/^# Project Start File: //')
        if [[ -n "$title" ]]; then
            echo "Title: $title"
        fi
    fi
    
    echo ""
    echo "Project path: $project_dir"
}

# Command: reset (destructive clean - strips to template)
# Command: reset (destructive clean - strips to template)
cmd_reset() {
    print_header
    
    echo -e "${RED}‚ö†Ô∏è  WARNING: DESTRUCTIVE OPERATION ‚ö†Ô∏è${NC}"
    echo ""
    
    echo -e "${CYAN}What would you like to reset?${NC}"
    echo "  [1] Active Project (Reset to template state, keep start.md/config)"
    echo "  [2] All Projects (Delete everything in documents/)"
    echo "  [3] Cancel"
    echo ""
    read -p "Select option [1-3]: " -r scope_choice
    echo ""
    
    if [[ "$scope_choice" == "3" ]]; then
        print_info "Reset cancelled"
        exit 0
    fi
    
    if [[ "$scope_choice" == "1" ]]; then
        # Reset active project
        local active=$(get_active_project)
        
        if [[ -z "$active" ]]; then
            print_error "No active project found."
            exit 1
        fi
        
        local project_dir=""
        if declare -f find_document_dir_by_id >/dev/null; then
            project_dir=$(find_document_dir_by_id "$PROJECT_ROOT" "$active")
        else
            project_dir="$PROJECT_ROOT/documents/$active"
        fi
        
        if [[ -z "$project_dir" || ! -d "$project_dir" ]]; then
            print_error "Project directory not found for: $active"
            exit 1
        fi
        
        echo -e "${YELLOW}This will:${NC}"
        echo "  ‚Ä¢ COMPLETELY DELETE the project folder: $project_dir"
        echo "  ‚Ä¢ Revert .latexkit-workspace to last commit (if changed)"
        echo ""
        echo -e "${RED}This action CANNOT be undone!${NC}"
        echo ""
        read -p "Type 'RESET' to confirm: " -r
        echo
        
        if [[ "$REPLY" != "RESET" ]]; then
            print_info "Reset cancelled"
            exit 0
        fi
        
        # Execute reset
        print_info "Removing project directory..."
        rm -rf "$project_dir"
        
        # Revert workspace state if modified
        local workspace_file="$PROJECT_ROOT/.latexkit-workspace"
        if [[ -f "$workspace_file" ]]; then
            if git -C "$PROJECT_ROOT" diff --quiet "$workspace_file"; then
                print_info ".latexkit-workspace is clean, no revert needed."
            else
                print_info "Reverting .latexkit-workspace to last commit..."
                git -C "$PROJECT_ROOT" checkout "$workspace_file" 2>/dev/null || git -C "$PROJECT_ROOT" restore "$workspace_file" 2>/dev/null || print_warning "Failed to revert workspace file (git might not be initialized or file is new)"
            fi
        fi
        
        print_success "Project '$active' removed and workspace reset."
        
    elif [[ "$scope_choice" == "2" ]]; then
        # Reset all projects
        
        echo -e "${YELLOW}This will PERMANENTLY DELETE:${NC}"
        echo "  ‚Ä¢ The entire 'documents/' directory"
        echo "  ‚Ä¢ All projects and work within it"
        echo ""
        echo -e "${RED}This action CANNOT be undone!${NC}"
        echo ""
        read -p "Type 'RESET' to confirm: " -r
        echo
        
        if [[ "$REPLY" != "RESET" ]]; then
            print_info "Reset cancelled"
            exit 0
        fi
        
        # Delete all projects
        print_info "Deleting all projects..."
        rm -rf "$PROJECT_ROOT/documents"
        mkdir -p "$PROJECT_ROOT/documents"
        
        # Clear active project
        set_workspace_state "ACTIVE_PROJECT" ""
        
        print_success "All projects deleted. documents/ directory is clean."
        
    else
        print_error "Invalid option selected"
        exit 1
    fi
}


case "$1" in
    new)
        shift
        cmd_new "$@"
        ;;
    plan)
        cmd_plan
        ;;
    start)
        print_warning "Deprecated: 'start' is aliased to 'plan'."
        cmd_plan
        ;;
    research)
        cmd_research
        ;;
    outline)
        cmd_outline
        ;;
    draft)
        cmd_draft
        ;;
    convert)
        cmd_convert
        ;;
    check)
        cmd_check
        ;;
    add)
        shift
        cmd_add "$@"
        ;;
    list)
        cmd_list
        ;;
    build)
        cmd_build
        ;;
    clean)
        cmd_clean
        ;;
    commit)
        shift
        cmd_commit "$@"
        ;;
    switch)
        shift
        # Define inline or load from common
        if [[ -z "$1" ]]; then
            print_warning "Usage: ./latexkit switch <project-id>"
            print_warning "Usage: ./latexkit switch <project-id>"
            cmd_projects
            exit 1
        fi
        cmd_switch "$1"
        ;;
    projects)
        cmd_projects
        ;;
    help|--help|-h)
        print_header
        echo "Usage: ./latexkit <command> [options]"
        echo ""
        echo "Workflow Commands (Sequential):"
        echo "  1. new       Create a new project"
        echo "  2. plan      [AI] Generate plan & initial prompt (formerly start)"
        echo "  3. research  [AI] Generate prompt for research phase"
        echo "  4. outline   [AI] Generate prompt for outlining phase"
        echo "  5. draft     [AI] Generate prompt for drafting phase"
        echo "  6. convert   [AI] Generate prompt for LaTeX conversion"
        echo ""
        echo "Tools:"
        echo "  build      Build the current project (PDF)"
        echo "  check      [AI] Analyze logs and latex source"
        echo "  commit     Smart commit with conventional messages"
        echo "  switch     Switch active project context"
        echo "  projects   List all projects"
        echo "  add        Add a component to the current project"
        echo "  list       List available layouts and components"
        echo "  clean      Clean build artifacts"
        echo ""
        ;;
    *)
        if [[ -n "$1" ]]; then
            print_error "Unknown command: $1"
            echo "Run './latexkit help' for usage"
            exit 1
        else
            # Default to help
            "$0" help
        fi
        ;;
esac
